<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plug Method · DHNetworkSimulator</title><meta name="title" content="Plug Method · DHNetworkSimulator"/><meta property="og:title" content="Plug Method · DHNetworkSimulator"/><meta property="twitter:title" content="Plug Method · DHNetworkSimulator"/><meta name="description" content="Documentation for DHNetworkSimulator."/><meta property="og:description" content="Documentation for DHNetworkSimulator."/><meta property="twitter:description" content="Documentation for DHNetworkSimulator."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DHNetworkSimulator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Plug Method</a><ul class="internal"><li><a class="tocitem" href="#Quasi-dynamic-assumption"><span>Quasi-dynamic assumption</span></a></li><li><a class="tocitem" href="#State-representation"><span>State representation</span></a></li><li><a class="tocitem" href="#One-simulation-time-step-(high-level)"><span>One simulation time step (high level)</span></a></li><li><a class="tocitem" href="#Forward-pass-(supply):-advection-and-splitting"><span>Forward pass (supply): advection and splitting</span></a></li><li><a class="tocitem" href="#Load-model:-consuming-heat"><span>Load model: consuming heat</span></a></li><li><a class="tocitem" href="#Backward-pass-(return):-advection-and-merging"><span>Backward pass (return): advection and merging</span></a></li><li><a class="tocitem" href="#Heat-loss-to-ambient-(dissipation-to-atmosphere)"><span>Heat loss to ambient (dissipation to atmosphere)</span></a></li><li><a class="tocitem" href="#Practical-notes-and-limitations"><span>Practical notes and limitations</span></a></li></ul></li><li><span class="tocitem">Network</span><ul><li><a class="tocitem" href="../Network/">Network</a></li><li><a class="tocitem" href="../types/">Nodes and Edges</a></li></ul></li><li><a class="tocitem" href="../simulation/">Simulation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Plug Method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plug Method</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plug-method"><a class="docs-heading-anchor" href="#Plug-method">Plug method</a><a id="Plug-method-1"></a><a class="docs-heading-anchor-permalink" href="#Plug-method" title="Permalink"></a></h1><p><em>One of the ways to solve thermo-dynamics with hydraulics.</em></p><p>This project solves heat transport in a district heating network using a <strong>plug-flow (parcel) method</strong>. Each pipe contains a queue of discrete <strong>plugs of water</strong>, where every plug has:</p><ul><li>temperature <code>T</code> [°C]</li><li>mass <code>m</code> [kg]</li></ul><p>Plugs advect through pipes according to the current mass flows, exchange heat with the environment via a simple heat-loss model, and (optionally) lose heat at loads according to the load power demand.</p><p>In this example image we can see, that with variable flow and temperature, in each period there may be multiple different sized plugs of different temperatures exiting a pipe. <img src="../plug_method.png" alt="plug_flow_example"/> <em>Figure: Explanation of plug method [doc. Ing. Zdeněk Hurák, Ph.D., CTU]</em></p><h2 id="Quasi-dynamic-assumption"><a class="docs-heading-anchor" href="#Quasi-dynamic-assumption">Quasi-dynamic assumption</a><a id="Quasi-dynamic-assumption-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-dynamic-assumption" title="Permalink"></a></h2><p>The approach of solving our thermodynamic problem of flow is based on a <strong>quasi-dynamic</strong> assumption:</p><ul><li><strong>Hydraulics</strong> (mass flow distribution) is assumed to reach steady state “instantaneously” compared to</li><li><strong>Thermal dynamics</strong>, which are dominated by advection (transport of hot water) and slow heat losses.</li></ul><p>As a result, each simulation time step does:</p><ol><li>compute steady-state mass flows (<code>steady_state_hydronynamics!</code>)</li><li>transport heat by moving plugs<ol><li>forward (supply) direction: from producer to loads</li><li>heat extraction at loads: using a power-demand model (often based on outdoor-temperature compensation, sometimes called <em>equithermal regulation</em>)</li><li>backward (return) direction: from loads back to the producer</li></ol></li></ol><h2 id="State-representation"><a class="docs-heading-anchor" href="#State-representation">State representation</a><a id="State-representation-1"></a><a class="docs-heading-anchor-permalink" href="#State-representation" title="Permalink"></a></h2><p>Each pipe edge represents two pipes and therefore stores two independent plug queues:</p><ul><li><code>plugs_f</code>: plugs moving in the <strong>forward/supply</strong> direction</li><li><code>plugs_b</code>: plugs moving in the <strong>backward/return</strong> direction</li></ul><p>Within a pipe, plugs are treated as <strong>non-mixing</strong> parcels (no axial mixing). Mixing is handled explicitly only where the network topology merges/splits flow.</p><h2 id="One-simulation-time-step-(high-level)"><a class="docs-heading-anchor" href="#One-simulation-time-step-(high-level)">One simulation time step (high level)</a><a id="One-simulation-time-step-(high-level)-1"></a><a class="docs-heading-anchor-permalink" href="#One-simulation-time-step-(high-level)" title="Permalink"></a></h2><p>For each time step of length Δt:</p><ol><li><strong>Insert new hot plugs at the producer</strong> into each outgoing supply pipe.</li><li><strong>Forward pass (supply)</strong>: move plugs from producer to loads using current mass flows.</li><li><strong>Loads</strong>: compute required power <span>$P(T_a)$</span> from ambient temperature and cool the arriving plug accordingly.</li><li><strong>Backward pass (return)</strong>: push cooled plugs back to the producer, mixing at junctions as needed.</li><li><strong>Heat losses to ambient</strong>: cool all plugs remaining in pipes (supply and return) using an exponential heat-loss model.</li></ol><p>The overall simulation loop is orchestrated by <code>run_simulation</code>.</p><hr/><h2 id="Forward-pass-(supply):-advection-and-splitting"><a class="docs-heading-anchor" href="#Forward-pass-(supply):-advection-and-splitting">Forward pass (supply): advection and splitting</a><a id="Forward-pass-(supply):-advection-and-splitting-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-pass-(supply):-advection-and-splitting" title="Permalink"></a></h2><h3 id="1)-Plug-injection-at-the-source"><a class="docs-heading-anchor" href="#1)-Plug-injection-at-the-source">1) Plug injection at the source</a><a id="1)-Plug-injection-at-the-source-1"></a><a class="docs-heading-anchor-permalink" href="#1)-Plug-injection-at-the-source" title="Permalink"></a></h3><p>For each outgoing edge from the producer, a new plug is created with:</p><p class="math-container">\[m_{in} = \dot m\,\Delta t\]</p><p>and temperature equal to the producer outlet temperature for that step. The plug is appended to that pipe’s forward queue.</p><h3 id="2)-Plug-advection-through-a-pipe"><a class="docs-heading-anchor" href="#2)-Plug-advection-through-a-pipe">2) Plug advection through a pipe</a><a id="2)-Plug-advection-through-a-pipe-1"></a><a class="docs-heading-anchor-permalink" href="#2)-Plug-advection-through-a-pipe" title="Permalink"></a></h3><p>For a pipe with mass flow <span>$\dot m$</span>, the algorithm computes the mass that must exit the pipe in this step:</p><p class="math-container">\[m_{out} = \dot m\,\Delta t\]</p><p>It then pops plugs from the <strong>front</strong> of the queue until the exiting mass is reached. If a plug is larger than the remaining mass to exit, it is <strong>split</strong> into an exiting part and a remaining part.</p><p>This is implemented by <code>collect_exiting_water_plugs!</code>.</p><h3 id="3)-Junction-splitting-(tree)"><a class="docs-heading-anchor" href="#3)-Junction-splitting-(tree)">3) Junction splitting (tree)</a><a id="3)-Junction-splitting-(tree)-1"></a><a class="docs-heading-anchor-permalink" href="#3)-Junction-splitting-(tree)" title="Permalink"></a></h3><p>When a node has multiple children, the exiting plug mass is split among outgoing edges proportional to edge mass flows:</p><p class="math-container">\[m_{child} = m_{plug}\,\frac{\dot m_{child}}{\sum_k \dot m_k}\]</p><p>Each child receives a new plug with the same temperature and the computed mass. These plugs are appended to the child edges’ forward queues.</p><h3 id="4)-Leaf-handling-(load-inlet-plug)"><a class="docs-heading-anchor" href="#4)-Leaf-handling-(load-inlet-plug)">4) Leaf handling (load inlet plug)</a><a id="4)-Leaf-handling-(load-inlet-plug)-1"></a><a class="docs-heading-anchor-permalink" href="#4)-Leaf-handling-(load-inlet-plug)" title="Permalink"></a></h3><p>At a leaf node, all plugs that arrive during the step are combined into a single representative plug using a <strong>mass-weighted average</strong>:</p><p class="math-container">\[T_{avg} = \frac{\sum_i T_i m_i}{\sum_i m_i}\]</p><p>This is implemented by <code>combine_plugs</code>.</p><p>The resulting plug is interpreted as the <strong>supply plug entering the load</strong> for this time step.</p><hr/><h2 id="Load-model:-consuming-heat"><a class="docs-heading-anchor" href="#Load-model:-consuming-heat">Load model: consuming heat</a><a id="Load-model:-consuming-heat-1"></a><a class="docs-heading-anchor-permalink" href="#Load-model:-consuming-heat" title="Permalink"></a></h2><p>Each load node computes power demand based on ambient temperature <span>$T_a$</span> (we use a 2nd-order polynomial approximation):</p><p class="math-container">\[P = P(T_a) = p_1 + p_2 T_a + p_3 T_a^2\]</p><p>The entering plug is cooled by energy extraction over the step:</p><p class="math-container">\[\Delta T = \frac{P\,\Delta t}{m\,c_p}\]</p><p>so the return-side plug temperature becomes <span>$T - \Delta T$</span>.</p><p>To avoid unphysical results (like cooling the plug to lower temperature than is inside the building), the implementation clamps return temperature to a configured minimal value (<code>MINIMAL_RETURN_TEMPERATURE = 25.0</code>).</p><hr/><h2 id="Backward-pass-(return):-advection-and-merging"><a class="docs-heading-anchor" href="#Backward-pass-(return):-advection-and-merging">Backward pass (return): advection and merging</a><a id="Backward-pass-(return):-advection-and-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-pass-(return):-advection-and-merging" title="Permalink"></a></h2><p>The backward pass pushes the cooled plugs from loads back to the producer using the return queues <code>plugs_b</code>.</p><h3 id="Leaf-injection"><a class="docs-heading-anchor" href="#Leaf-injection">Leaf injection</a><a id="Leaf-injection-1"></a><a class="docs-heading-anchor-permalink" href="#Leaf-injection" title="Permalink"></a></h3><p>At each load (leaf), the cooled plug is pushed into the parent edge’s return queue.</p><h3 id="Junction-merging"><a class="docs-heading-anchor" href="#Junction-merging">Junction merging</a><a id="Junction-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Junction-merging" title="Permalink"></a></h3><p>At an internal node, return plugs are collected from each child return edge (again using <code>collect_exiting_water_plugs!</code>). These multiple plug sequences must be merged into a single sequence going into the parent.</p><p>The code uses <code>merge_water_plug_vectors!</code>, which mixes the plugs according to the individual flows in merging pipes.</p><p>At the producer root, the merged plug sequence is combined to a single plug representing the <strong>return temperature entering the producer</strong> for that step.</p><hr/><h2 id="Heat-loss-to-ambient-(dissipation-to-atmosphere)"><a class="docs-heading-anchor" href="#Heat-loss-to-ambient-(dissipation-to-atmosphere)">Heat loss to ambient (dissipation to atmosphere)</a><a id="Heat-loss-to-ambient-(dissipation-to-atmosphere)-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-loss-to-ambient-(dissipation-to-atmosphere)" title="Permalink"></a></h2><p>After advection, both in forward and backward pass, the remaining plugs in pipes are cooled to account for heat loss to the environment.</p><p>For each plug, temperature is updated using an exponential model:</p><p class="math-container">\[T_{next} = T_a + (T - T_a)\exp\left(-\frac{\Delta t}{\rho c_p A R}\right)\]</p><p>where:</p><ul><li><span>$\rho$</span> is water density (<code>WATER_DENSITY</code>)</li><li><span>$c_p$</span> is specific heat (<code>WATER_SPECIFIC_HEAT</code>)</li><li><span>$A$</span> is cross-sectional area of the pipe <span>$A = \pi(\frac{d}{2})^2$</span></li><li><span>$R$</span> is pipe thermal resistance ... this is given by pipe insulation and usually differs for forward and backward pass</li></ul><hr/><h2 id="Practical-notes-and-limitations"><a class="docs-heading-anchor" href="#Practical-notes-and-limitations">Practical notes and limitations</a><a id="Practical-notes-and-limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-notes-and-limitations" title="Permalink"></a></h2><ul><li>The current network traversal assumes a <strong>directed tree</strong> (each non-root node has one parent).</li><li>There is <strong>no axial mixing</strong> inside a pipe: plugs only merge when explicitly combined (e.g., at reporting points or junction return merging).</li><li>The plug representation is simplified over time by merging consecutive plugs with nearly identical temperature (<code>merge_same_temperature_plugs!</code>).</li><li>Stability and realism depend on choosing a reasonable Δt relative to flows and pipe volumes.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Network/">Network »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 12 February 2026 18:17">Thursday 12 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
