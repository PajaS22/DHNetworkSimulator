var documenterSearchIndex = {"docs":
[{"location":"simulation/#Simulation","page":"Simulation","title":"Simulation","text":"This page describes how to run simulations with DHNetworkSimulator and how to interpret the results.\n\nThe simulation follows a quasi-dynamic approach:\n\nHydraulics are treated as steady state at each time step (mass flow distribution updates “instantly”).\nThermal dynamics are simulated by advecting discrete plugs of water through pipes.\n\nFor details of the plug model, see Plug method.","category":"section"},{"location":"simulation/#Run-simulation:-run_simulation","page":"Simulation","title":"Run simulation: run_simulation","text":"The main function is run_simulation(network, sim_time, policy; ...).\n\nAt a high level, for each step it:\n\ncalls policy(t, Tₐ, T_back) to get producer setpoints (ProducerOutput),\ncomputes steady-state mass flows (steady_state_hydronynamics!),\npropagates plugs forward (supply), applies load consumption, then propagates plugs backward (return),\nrecords temperatures / flows / powers into a SimulationResults.\n\nnote: Network is validated automatically\nrun_simulation calls check_network! before the first step. You do not need to call it manually as long as you constructed a valid directed tree with one producer and load leaves.\n\nExample of constant policy:\n\nfunction policy(t, Tₐ, T_back)\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\nExample of variable policy\n\nfunction policy(t, Tₐ, T_back)\n    T = 90 + 10*sin(2π*t/(24*3600)) # period of 24 hours\n\treturn ProducerOutput(mass_flow=15.0, temperature=T)\nend","category":"section"},{"location":"simulation/#Producer-setpoint","page":"Simulation","title":"Producer setpoint","text":"","category":"section"},{"location":"simulation/#Simulation-logs:","page":"Simulation","title":"Simulation logs:","text":"Simulation logs data in struct SimulationResults.","category":"section"},{"location":"simulation/#Visualization-of-SimulationResults","page":"Simulation","title":"Visualization of SimulationResults","text":"SimulationResults can be easily displayed using function plot_simulation_results.","category":"section"},{"location":"simulation/#Minimal-workflow-(end-to-end)","page":"Simulation","title":"Minimal workflow (end-to-end)","text":"The typical workflow is:\n\nbuild a Network (see Network),\nattach node/edge parameters,\ndefine sim_time and policy, (optionally get also measurements of temperature)\ncall run_simulation,\nvisualize time series via plot_simulation_results.","category":"section"},{"location":"simulation/#Examples","page":"Simulation","title":"Examples","text":"","category":"section"},{"location":"simulation/#Example-1:-sinusoidal-temperature","page":"Simulation","title":"Example 1: sinusoidal temperature","text":"using DHNetworkSimulator\n\n# network = ... build/parameterize a valid Network ...\n\nt = float.(collect(range(0, stop=3*60*60, step=60))) # simulate for three hours with 1 min time step\n# sinusoidal mass flow and temperature\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 15.0\n    temp = 90 + 10*sin(2π*t/(100*60)) # period of 100 minutes, oscillation between 80 and 100 °C\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\nplot_simulation_results(results, :T_load_in; title=\"Load Inlet Temperatures\")\n\n(Image: example 1 result)\n\nExample 1: sinusoidal temperature on input","category":"section"},{"location":"simulation/#Example-2:-varying-outdoor-temperature","page":"Simulation","title":"Example 2: varying outdoor temperature","text":"In real world there is time varying outdoor temperature, which has impact on the dissipation of energy during transport (if we have good isolation, not so much). Also, consumers consume more energy, when it's cold outside.\n\nWe have a measurement of real outdoor temperature in May 2024, lets try use it!\n\nAlso, our power plans surely has some limits, let's specify the power output to be 4 MW.\n\ntime_interval = [DateTime(2024, 5, 1), DateTime(2024, 5, 21)]\nTₐ = TSFrames.subset(outdoor_temperature_ts, time_interval...) # select only relevant interval\nTₐ_vec = Tₐ[:, :T_a_avg] # convert TSFrame to vector of outdoor temperatures for each time step\n\nt =  index(Tₐ) # get time vector in DateTime format\n\nproducer_power = 4_000_000.0 # 4 MW\nc_water = 4186.0 # J/(kg*K)\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 80.0 # constant mass flow of 80 kg/s\n    # P = (T2-T1) * mass_flow * water_specific_heat\n    temp = producer_power / (mass_flow * c_water) + T_back\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)\nplot_simulation_results(results, :T_load_out; title=\"Return temperatures on load side\")\n\n(Image: example 2 result)\n\nExample 2: varying outdoor temperature","category":"section"},{"location":"simulation/#Example-3:-control-the-output-temperature-with-constrained-power","page":"Simulation","title":"Example 3: control the output temperature with constrained power","text":"It's easy to say \"let's just produce water of 90°C\". To do that, we have to heat up the water and for that to happen, we must give the water considerable amount of energy. In real world, producers have some upper limits of energy they can deliver per second.\n\nLet's model that!\n\n# ... t, Tₐ_vec same as in previous example... #\n\nT_target = 90               # our target temperature\nPwr_max =  5_000_000.0      # maximal power output 5 MW\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 80.0\n    P_target = (T_target - T_back) * mass_flow * c_water # power needed to reach T_target\n    P = min(P_target, Pwr_max)\n    temp = P / (mass_flow * c_water) + T_back\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)\nplot_simulation_results(results, :T_producer_out; title=\"Producer output temperature\", linestyle=:solid)\nplot_simulation_results(results, :power_load)\n\n(Image: example 3 producer output)\n\nExample 3: Producer is able to control temperature to 90°C most of the time.\n\n(Image: example 3 producer output)\n\nExample 3: Power consumption of loads depend on temperature, we see, that in some intervals, it sums up so much, that the total power consumption is higher that power production and water gets colder.","category":"section"},{"location":"simulation/#DHNetworkSimulator.run_simulation","page":"Simulation","title":"DHNetworkSimulator.run_simulation","text":"Run a quasi-dynamic simulation of a district heating network.\n\nrun_simulation(network, sim_time, policy; T0_f=60.0, T0_b=25.0, ambient_temperature=nothing)\n\nThis is the main entry point for time stepping.\n\nREPEAT for N time steps:\n\ncomputes a steady-state hydraulic solution (mass flow distribution),\nadvances thermal dynamics using the plug-flow method:\nforward/supply advection producer → loads,\nheat consumption at loads,\nbackward/return advection loads → producer,\nheat losses to ambient.\n\nSee Plug method for the underlying model.\n\nOutput\n\nSimulationResults struct containing time series of temperatures, flows, and powers for all nodes and edges.\n\nArguments\n\nnetwork::Network: prepared network (producer/load nodes identified, pipes attached).\nsim_time: equally spaced time vector.\nVector{Float64}: time in seconds.\nVector{DateTime}: timestamps (Δt is interpreted in seconds).\npolicy::Function: callback returning ProducerOutput.\nSignature: policy(t, Tₐ, T_back)::ProducerOutput\nTₐ is ambient temperature at time t or nothing.\nT_back is the return temperature entering the producer (in previous time step k-1).\n\nKeyword Arguments\n\nT0_f: initial temperature forward part of the network (producer → loads) (°C).\nT0_b: initial temperature in backward part of the network (loads → producer) (°C).\nambient_temperature: optional Vector{Float64} of ambient (outdoor/atmospheric) temperatures (°C), length must match sim_time.\n\nReturns\n\nSimulationResults: time series of temperatures, flows, and powers.\n\nNotes\n\nThe network structure is validated once at the start via check_network!.\nTime steps must be equally spaced.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#DHNetworkSimulator.ProducerOutput","page":"Simulation","title":"DHNetworkSimulator.ProducerOutput","text":"Control input returned by a simulation policy.\n\nProducerOutput represents the producer setpoints for one time step.\n\nstruct ProducerOutput\n    mass_flow::Float64\n    temperature::Float64\nend\n\nFields\n\nmass_flow: total mass flow injected into the network in kg/s.\ntemperature: producer outlet (supply) temperature in °C.\n\nUsage\n\nThe policy passed to run_simulation must return a ProducerOutput:\n\nfunction policy(t, Tₐ, T_back)\n    return ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n\n\n\n\n","category":"type"},{"location":"simulation/#DHNetworkSimulator.SimulationResults","page":"Simulation","title":"DHNetworkSimulator.SimulationResults","text":"Results of a simulation run.\n\nSimulationResults stores the time series produced by run_simulation.\n\nstruct SimulationResults\n        time::Union{Vector{Float64}, Vector{DateTime}}\n        mass_flow_load::Matrix{Float64}\n        mass_flow_producer::Vector{Float64}\n        T_load_in::Matrix{Float64}\n        T_load_out::Matrix{Float64}\n        T_producer_in::Vector{Float64}\n        T_producer_out::Vector{Float64}\n        power_load::Matrix{Float64}\n        power_producer::Vector{Float64}\n        load_labels::Dict{String, Int}\nend\n\nFields\n\ntime: simulation time vector.\nVector{Float64}: time in seconds.\nVector{DateTime}: absolute timestamps.\nmass_flow_load: load mass flows in kg/s. Size N × nloads.\nmass_flow_producer: producer mass flow in kg/s. Length N.\nT_load_in: temperature entering each load (supply side) in °C. Size N × nloads.\nT_load_out: temperature leaving each load (return side) in °C. Size N × nloads.\nT_producer_in: return temperature entering the producer in °C. Length N.\nT_producer_out: supply temperature leaving the producer in °C. Length N.\npower_load: load power consumption in kW. Size N × nloads.\npower_producer: producer power output in MW (computed from mass flow and ΔT). Length N-1.\nload_labels: mapping from load label to column index used in the *_load matrices.\n\nIndexing\n\nConvenience accessors are provided:\n\nsr[:time] returns the time vector.\nsr[:load_labels] returns the load labels.\nsr[:load_labels_dict] returns the label→column dictionary.\nsr[\"L1\", :T_load_in] returns the time series for that load L1 (a vector).\n\nNotes\n\nAll matrices are organized as (time step, load index).\npower_producer has length N-1 because the producer heats the water that entered in in previous! time step.\n\n\n\n\n\n","category":"type"},{"location":"simulation/#DHNetworkSimulator.plot_simulation_results","page":"Simulation","title":"DHNetworkSimulator.plot_simulation_results","text":"Plot time series from SimulationResults.\n\nplot_simulation_results is a small helper around Plots.jl that plots one physical variable either:\n\nfor selected load labels, or\nfor the producer (for producer-only variables).\n\nplot_simulation_results(sr::SimulationResults, physical_var::Symbol; kwargs...)\nplot_simulation_results(sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)\nplot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, physical_var::Symbol; kwargs...)\nplot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)\n\nArguments\n\nsr::SimulationResults: simulation output from run_simulation.\nlabels::Vector{String}: load labels to include in plot (only used for load variables),                           if not provided, all load labels are plotted.\nphysical_var::Symbol: what values to plot.   Supported options are:\ntemperatures: :T_load_in, :T_load_out, :T_producer_in, :T_producer_out\nmass flows: :mass_flow_load, :mass_flow_producer\npowers: :power_load, :power_producer\nplot::Plots.Plot{Plots.GRBackend}: an existing plot to add lines to,                                      if not provided, a new plot is created.\n\nKeyword Arguments\n\nkwargs...: forwarded to Plots.plot! (e.g. linewidth, color, legend, ...).\n\nReturns\n\nThe Plots.Plot object.\n\nNotes\n\nIf sr[:time] is Vector{Float64}, the x-axis is converted from seconds to minutes.\n:power_producer has length N-1 and is plotted against time[1:end-1].\nWhen plotting producer variables, the line style defaults to dashed (unless you override linestyle).\n\nExamples\n\nsr = run_simulation(network, t, policy)\n\nplot_simulation_results(sr, :T_load_in)\nplot_simulation_results(sr, [\"L1\", \"L2\"], :mass_flow_load)\nplot_simulation_results(sr, :power_producer)\n\n\n\n\n\n","category":"function"},{"location":"Plug_method/#Plug-method","page":"Plug Method","title":"Plug method","text":"One of the ways to solve thermo-dynamics with hydraulics.\n\nThis project solves heat transport in a district heating network using a plug-flow (parcel) method. Each pipe contains a queue of discrete plugs of water, where every plug has:\n\ntemperature T [°C]\nmass m [kg]\n\nPlugs advect through pipes according to the current mass flows, exchange heat with the environment via a simple heat-loss model, and (optionally) lose heat at loads according to the load power demand.\n\nIn this example image we can see, that with variable flow and temperature, in each period there may be multiple different sized plugs of different temperatures exiting a pipe. (Image: plug_flow_example) Figure: Explanation of plug method [doc. Ing. Zdeněk Hurák, Ph.D., CTU]","category":"section"},{"location":"Plug_method/#Quasi-dynamic-assumption","page":"Plug Method","title":"Quasi-dynamic assumption","text":"The approach of solving our thermodynamic problem of flow is based on a quasi-dynamic assumption:\n\nHydraulics (mass flow distribution) is assumed to reach steady state “instantaneously” compared to\nThermal dynamics, which are dominated by advection (transport of hot water) and slow heat losses.\n\nAs a result, each simulation time step does:\n\ncompute steady-state mass flows (steady_state_hydronynamics!)\ntransport heat by moving plugs\nforward (supply) direction: from producer to loads\nheat extraction at loads: using a power-demand model (often based on outdoor-temperature compensation, sometimes called equithermal regulation)\nbackward (return) direction: from loads back to the producer","category":"section"},{"location":"Plug_method/#State-representation","page":"Plug Method","title":"State representation","text":"Each pipe edge represents two pipes and therefore stores two independent plug queues:\n\nplugs_f: plugs moving in the forward/supply direction\nplugs_b: plugs moving in the backward/return direction\n\nWithin a pipe, plugs are treated as non-mixing parcels (no axial mixing). Mixing is handled explicitly only where the network topology merges/splits flow.","category":"section"},{"location":"Plug_method/#One-simulation-time-step-(high-level)","page":"Plug Method","title":"One simulation time step (high level)","text":"For each time step of length Δt:\n\nInsert new hot plugs at the producer into each outgoing supply pipe.\nForward pass (supply): move plugs from producer to loads using current mass flows.\nLoads: compute required power P(T_a) from ambient temperature and cool the arriving plug accordingly.\nBackward pass (return): push cooled plugs back to the producer, mixing at junctions as needed.\nHeat losses to ambient: cool all plugs remaining in pipes (supply and return) using an exponential heat-loss model.\n\nThe overall simulation loop is orchestrated by run_simulation.\n\n","category":"section"},{"location":"Plug_method/#Forward-pass-(supply):-advection-and-splitting","page":"Plug Method","title":"Forward pass (supply): advection and splitting","text":"","category":"section"},{"location":"Plug_method/#1)-Plug-injection-at-the-source","page":"Plug Method","title":"1) Plug injection at the source","text":"For each outgoing edge from the producer, a new plug is created with:\n\nm_in = dot mDelta t\n\nand temperature equal to the producer outlet temperature for that step. The plug is appended to that pipe’s forward queue.","category":"section"},{"location":"Plug_method/#2)-Plug-advection-through-a-pipe","page":"Plug Method","title":"2) Plug advection through a pipe","text":"For a pipe with mass flow dot m, the algorithm computes the mass that must exit the pipe in this step:\n\nm_out = dot mDelta t\n\nIt then pops plugs from the front of the queue until the exiting mass is reached. If a plug is larger than the remaining mass to exit, it is split into an exiting part and a remaining part.\n\nThis is implemented by collect_exiting_water_plugs!.","category":"section"},{"location":"Plug_method/#3)-Junction-splitting-(tree)","page":"Plug Method","title":"3) Junction splitting (tree)","text":"When a node has multiple children, the exiting plug mass is split among outgoing edges proportional to edge mass flows:\n\nm_child = m_plugfracdot m_childsum_k dot m_k\n\nEach child receives a new plug with the same temperature and the computed mass. These plugs are appended to the child edges’ forward queues.","category":"section"},{"location":"Plug_method/#4)-Leaf-handling-(load-inlet-plug)","page":"Plug Method","title":"4) Leaf handling (load inlet plug)","text":"At a leaf node, all plugs that arrive during the step are combined into a single representative plug using a mass-weighted average:\n\nT_avg = fracsum_i T_i m_isum_i m_i\n\nThis is implemented by combine_plugs.\n\nThe resulting plug is interpreted as the supply plug entering the load for this time step.\n\n","category":"section"},{"location":"Plug_method/#Load-model:-consuming-heat","page":"Plug Method","title":"Load model: consuming heat","text":"Each load node computes power demand based on ambient temperature T_a (we use a 2nd-order polynomial approximation):\n\nP = P(T_a) = p_1 + p_2 T_a + p_3 T_a^2\n\nThe entering plug is cooled by energy extraction over the step:\n\nDelta T = fracPDelta tmc_p\n\nso the return-side plug temperature becomes T - Delta T.\n\nTo avoid unphysical results (like cooling the plug to lower temperature than is inside the building), the implementation clamps return temperature to a configured minimal value (MINIMAL_RETURN_TEMPERATURE = 25.0).\n\n","category":"section"},{"location":"Plug_method/#Backward-pass-(return):-advection-and-merging","page":"Plug Method","title":"Backward pass (return): advection and merging","text":"The backward pass pushes the cooled plugs from loads back to the producer using the return queues plugs_b.","category":"section"},{"location":"Plug_method/#Leaf-injection","page":"Plug Method","title":"Leaf injection","text":"At each load (leaf), the cooled plug is pushed into the parent edge’s return queue.","category":"section"},{"location":"Plug_method/#Junction-merging","page":"Plug Method","title":"Junction merging","text":"At an internal node, return plugs are collected from each child return edge (again using collect_exiting_water_plugs!). These multiple plug sequences must be merged into a single sequence going into the parent.\n\nThe code uses merge_water_plug_vectors!, which mixes the plugs according to the individual flows in merging pipes.\n\nAt the producer root, the merged plug sequence is combined to a single plug representing the return temperature entering the producer for that step.\n\n","category":"section"},{"location":"Plug_method/#Heat-loss-to-ambient-(dissipation-to-atmosphere)","page":"Plug Method","title":"Heat loss to ambient (dissipation to atmosphere)","text":"After advection, both in forward and backward pass, the remaining plugs in pipes are cooled to account for heat loss to the environment.\n\nFor each plug, temperature is updated using an exponential model:\n\nT_next = T_a + (T - T_a)expleft(-fracDelta trho c_p A Rright)\n\nwhere:\n\nrho is water density (WATER_DENSITY)\nc_p is specific heat (WATER_SPECIFIC_HEAT)\nA is cross-sectional area of the pipe A = pi(fracd2)^2\nR is pipe thermal resistance ... this is given by pipe insulation and usually differs for forward and backward pass\n\n","category":"section"},{"location":"Plug_method/#Practical-notes-and-limitations","page":"Plug Method","title":"Practical notes and limitations","text":"The current network traversal assumes a directed tree (each non-root node has one parent).\nThere is no axial mixing inside a pipe: plugs only merge when explicitly combined (e.g., at reporting points or junction return merging).\nThe plug representation is simplified over time by merging consecutive plugs with nearly identical temperature (merge_same_temperature_plugs!).\nStability and realism depend on choosing a reasonable Δt relative to flows and pipe volumes.","category":"section"},{"location":"Network/#Network","page":"Network","title":"Network","text":"Network is the main model type in DHNetworkSimulator. It represents a district heating network as a directed graph:\n\nwater flows from one producer (the source/root),\nthrough optional junctions (branching/merging points),\nto multiple loads (consumers, typically leaves).\n\nUnlike a plain graph, a Network stores typed domain data on:\n\nnodes: ProducerNode, JunctionNode, LoadNode (plus EmptyNode as a placeholder during construction),\nedges: typically InsulatedPipe (plus EmptyEdge as a placeholder during construction).\nmore on nodes and edges in Network nodes and edges\n\nThis design makes it straightforward to build a topology, attach physical parameters, and run the hydraulic + thermal simulation.","category":"section"},{"location":"Network/#What-It-Stores","page":"Network","title":"What It Stores","text":"","category":"section"},{"location":"Network/#Features","page":"Network","title":"Features","text":"","category":"section"},{"location":"Network/#MetaGraph","page":"Network","title":"MetaGraph","text":"For the internal graph structure we use MetaGraph MetaGraphNext.jl, because it is type stable (not like MetaGraphs.jl). We prefer it over Graphs.jl for 2 main reasons:\n\ngraph from Graphs.jl has not stable indexing: when a node is removed, all the nodes are reindexed so that there are no gaps in indexing. For example we have graph with three vertices {V[1], V[2], V[3]}. If we remove the middle vertex V[2], the vertex V[3]'s indexing is changed to be V[2]. On the other hand, if we remove vertex V[B] from metagraph {V[A], V[B], V[C]}, the indexing (or rather labeling) stays the same and we get {V[A], V[C]}\nMetaGraph lets us store node/edge data on the vertices/edges.","category":"section"},{"location":"Network/#Indexing-by-Labels","page":"Network","title":"Indexing by Labels","text":"Nodes and edges are addressed by string labels:\n\nnw[\"A\"] returns the node data for label \"A\".\nnw[\"A\", \"B\"] returns the edge data from \"A\" to \"B\".\n\nBecause Network subtypes AbstractGraph, you can also use Graphs.jl-style APIs such as nv, ne, vertices, and edges.\n\nwarning: Graphs.jl indices vs MetaGraphNext labels\nFunctions like vertices, edges, src(e), dst(e) from Graphs.jl give you vertex indices from the underlying graph. To convert an index back to a label, use label_for(nw, idx).","category":"section"},{"location":"Network/#Structural-Assumptions-(Validated-at-Simulation-Start)","page":"Network","title":"Structural Assumptions (Validated at Simulation Start)","text":"The simulator assumes the network is static during a run (topology does not change while stepping). Before simulation starts, DHNetworkSimulator validates that:\n\nthere is exactly one producer node (producer_label must be set),\nthe directed graph is acyclic,\nthe graph is connected (all nodes are reachable from the producer),\nload nodes are leaves (outdegree 0).\n\nrun_simulation calls check_network! internally before the first step, which does all of that, no need to do it yourself.","category":"section"},{"location":"Network/#Neighbor-Caching-(NeighborDicts)","page":"Network","title":"Neighbor Caching (NeighborDicts)","text":"Thermal and hydraulic stepping frequently calls outneighbors(nw, label) and inneighbors(nw, label). To reduce allocations and repeated work, Network maintains cached neighbor lists in NeighborDicts:\n\nWhen you modify the network structure (add/remove/rename nodes or edges), the cache is marked dirty. It is rebuilt automatically when needed (for example in run_simulation via check_network!). Also simple call outneighbors(network,label) makes the cache update if marked dirty.","category":"section"},{"location":"Network/#Typical-Workflows","page":"Network","title":"Typical Workflows","text":"","category":"section"},{"location":"Network/#1)-Create-a-Network-From-a-Graph-Topology","page":"Network","title":"1) Create a Network From a Graph Topology","text":"Use this when the topology already exists (e.g., imported from data or generated programmatically) and you want to attach node/edge data afterward.\n\nusing DHNetworkSimulator\nusing Graphs\n\n# 1 -> 2 -> 3, and 2 -> 4\ng = DiGraph(4)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 2, 4)\n\nnw = Network(g)\nname_nodes!(nw, [\"P\", \"J\", \"L1\", \"L2\"]) # rename 1..n to meaningful labels\nidentify_producer_and_loads!(nw)            # assign Producer/Junction/Load node types\n\n# attach pipe parameters (edge data)\nnw[\"P\", \"J\"]  = InsulatedPipe(\"P→J\";  length=300.0, inner_diameter=0.10)\nnw[\"J\", \"L1\"] = InsulatedPipe(\"J→L1\"; length=150.0, inner_diameter=0.08)\nnw[\"J\", \"L2\"] = InsulatedPipe(\"J→L2\"; length=180.0, inner_diameter=0.08)\n\nne(nw), nv(nw)\n\nWe can also display all sorts of info about the network:\n\njulia> nw\nDH Network:\n Number of nodes: 4\n Number of edges: 3\n Producer node: P\n Load nodes (2): {L1, L2}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] L1 : Load Node, Info: L1, Load (at 0°C): 540.0 kW\n[2] P : Producer Node, Info: P\n[3] J : Junction Node, Info: J\n[4] L2 : Load Node, Info: L2, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[2] P -->  [3] J : Pipe Edge, L=300.0, D_in=0.1, R_f=3.0, R_b=4.0\n[3] J -->  [1] L1 : Pipe Edge, L=150.0, D_in=0.08, R_f=3.0, R_b=4.0\n[3] J -->  [4] L2 : Pipe Edge, L=180.0, D_in=0.08, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#2)-Build-a-Small-Network-Manually","page":"Network","title":"2) Build a Small Network Manually","text":"For quick experiments you can start from Network() and assign nodes/edges directly by label.\n\nusing DHNetworkSimulator\n\nnw = Network()\nnw[\"P\"]  = ProducerNode(\"Plant\", (0.0, 0.0))\nnw[\"L1\"] = LoadNode(\"House 1\", (1.0, 0.0))\n\nnw[\"P\", \"L1\"] = InsulatedPipe(\"P→L1\"; length=200.0, inner_diameter=0.10)\n\njulia> nw\nDH Network:\n Number of nodes: 2\n Number of edges: 1\n Producer node: P\n Load nodes (1): {L1}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] P : Producer Node, Info: Plant\n[2] L1 : Load Node, Info: House 1, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[1] P -->  [2] L1 : Pipe Edge, L=200.0, D_in=0.1, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#Network-visualization","page":"Network","title":"Network visualization","text":"Visualization (plotting) of network is another feature that will come in handy. We can pan, zoom and if we hover over an edge, it turns red and additional info is shown.\n\nBy calling visualize_graph!(network) we get Makies display of our network.\n\nBlue nodes are loads, green is producer, black lines are pipes. The thicker the line, the bigger the pipe.\n\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz1) Vizualization of example network\n\nIf there is computed steady state flow first, the visualization shows the flow in the edges as well. The darker the more flow there is, which makes easy to analyze turbulance. Also, additional info is written in labels next to the edges and the exact flow velocity in [m/s] is shown upon hover.\n\nsteady_state_hydronynamics!(network, 100.0)\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz2) Zoomed in part of a network after computing steady state of hydrodynamics","category":"section"},{"location":"Network/#When-to-Use-Network","page":"Network","title":"When to Use Network","text":"Network is intended for modeling and simulation tasks such as:\n\nControl and policy studies: define a policy(t, Tₐ, T_back) callback and see how actions affect supply/return temperatures.\nDesign what-ifs: change pipe parameters and compare temperature drops, delays, and load satisfaction.\nTopology experiments: evaluate different branching structures and relative flow splits.\nVisualization & debugging: inspect the graph, pipe information, and computed flows.","category":"section"},{"location":"Network/#DHNetworkSimulator.Network","page":"Network","title":"DHNetworkSimulator.Network","text":"Network type representing a district heating network.\n\nmutable struct Network{T<:Integer} <: AbstractGraph{T}\n    mg::MetaGraph                               # MetaGraph from MetaGraphs.jl, it contains the network \n                                                    structure and node and edge data\n    producer_label::Union{Nothing, String}      # Label of the producer node\n    load_labels::Set{String}                    # Labels of the consumer nodes\n    neighbor_dicts::NeighborDicts               # Mappings to inneghbors and outneighbors for efficient access during simulation\nend\n\nFields\n\nmg: a MetaGraphsNext MetaGraph that contains the directed topology and stores node/edge data.\nproducer_label: label of the single producer node (or nothing if not yet set).\nload_labels: a set of labels for load nodes.\nneighbor_dicts: cached neighbor lists used to reduce allocations during simulation.\n\nConstructors\n\nNetwork(): Creates an empty DH network with no nodes or edges.\nNetwork(g::DiGraph): Creates a DH network from an existing directed graph structure ('Graphs.jl').                        Nodes and edges are initialized with EmptyNode and EmptyEdge data.\n\n\n\n\n\n","category":"type"},{"location":"Network/#DHNetworkSimulator.NeighborDicts","page":"Network","title":"DHNetworkSimulator.NeighborDicts","text":"Mappings to inneghbors and outneighbors for efficient access during simulation, stored in the Network struct.\n\nWhen calling functions outneighbors(nw, label) or inneighbors(nw, label),  there is no need to scan through the graph and collect neighbors,  instead we can directly access the pre-computed neighbor lists in the dictionaries. This significantly lowers the number of allocations during simulation, because there is a lot of places where we need to access neighbors of a node.\n\nThe network is static during the simulation, so we can compute these neighbor lists once before the simulation starts and then reuse them.\n\nmutable struct NeighborDicts\n    outneighbors::Dict{String, Vector{String}}       # mapping nodes to outneighbors for efficient access in simulation\n    inneighbors::Dict{String, Vector{String}}        # mapping nodes to inneighbors for efficient access in simulation\n    need_rebuild::Bool                               # flag to indicate if neighbor dicts need to be rebuilt before simulation\nend\n\nneed_rebuild flag is used to indicate when the neighbor dicts need to be updated  (e.g., after adding/removing nodes or edges), so that we can avoid unnecessary   rebuilding during multiple modifications.\n\nConstructor\n\nNeighborDicts(): Creates an instance of NeighborDicts with empty dictionaries and the need_rebuild flag set to true.\n\n\n\n\n\n","category":"type"},{"location":"#Distributed-Heating-Network-Simulator","page":"Home","title":"Distributed Heating Network Simulator","text":"This is the Documentation for DHNetworkSimulator.\n\nDHNetworkSimulator is a Julia package for building, visualizing, and simulating district heating networks. Network is represented as directed tree graph, root node is producer and leaf are consumers (loads).\n\nThermodynamics is solved using quazi-dynamic assumption, which makes the problem tractable. The assumption is that hydraulics (change in flow, pressures) has frequency much higher than thermics (change in temperature). In simple words, pressure moves in water with speed of sound and temperature moves mainly with advection (the hot water itself moves).\n\nWe solve the dynamics in two steps:\n\nfind steady state of hydraulics\nsolve thermics by moving \"plugs\" of water. Consecutive plugs dont mix.\n\nMore on plug method in Plug method.\n\nsmall change","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install the package, open the Julia REPL and type\n\njulia> using Pkg; Pkg.add(url=\"https://github.com/PajaS22/DHNetworkSimulator\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"The easiest way to get a feel for the API is to run one of the example scripts.\n\nscripts/basic_network.jl\nscripts/bigger_network.jl","category":"section"},{"location":"#Minimal-example-(policy-driven-simulation)","page":"Home","title":"Minimal example (policy-driven simulation)","text":"run_simulation takes a network, a time vector, and a policy(t, Tₐ, T_back) callback that returns a ProducerOutput. Simulation than returns SimulationResults struct holding  time series of many physical variables of the network.\n\nusing DHNetworkSimulator\n\nnetwork = Network()\nnetwork[\"producer\"] = ProducerNode((0.0, 0.0))\n\n# ... add junctions/loads/pipes here ...\n\nt = collect(0.0:60.0:3*3600.0) # seconds\n\nfunction policy(t, Tₐ, T_back) # constant flow and temperature\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n# set initial temperatures in pipes to 75°C and 60°C\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\n# plot temperature of water entering loads\nplot_simulation_results(results, :T_load_in)","category":"section"},{"location":"types/#Network-nodes-and-edges","page":"Nodes and Edges","title":"Network nodes and edges","text":"This page documents the core data types used to represent a district heating network.\n\nThe package models a network as a directed graph where:\n\nvertices are nodes (ProducerNode, JunctionNode, LoadNode), and\nedges are pipes (InsulatedPipe) carrying water plugs.","category":"section"},{"location":"types/#Conventions","page":"Nodes and Edges","title":"Conventions","text":"Temperatures are in °C.\nMass flow is in kg/s.\nPipe lengths are in m, inner diameters in m.\nPower demand curves in LoadNode use coefficients in kW.\n\nnote: `missing` means not initialized\nMany fields use missing to represent “not set” or “not computed yet”. For example, mass_flow is typically filled during the steady-state hydraulics step.","category":"section"},{"location":"types/#Nodes","page":"Nodes and Edges","title":"Nodes","text":"","category":"section"},{"location":"types/#Edges","page":"Nodes and Edges","title":"Edges","text":"","category":"section"},{"location":"types/#DHNetworkSimulator.NodeType","page":"Nodes and Edges","title":"DHNetworkSimulator.NodeType","text":"Abstract supertype for all node types in a district heating network.\n\nConcrete node types describe the role of a vertex in the directed network:\n\nProducerNode: heat source (root)\nJunctionNode: branching/merging point\nLoadNode: heat consumer (typically a leaf)\nEmptyNode: placeholder used during construction\n\nAll concrete node types store a common::NodeCommon field with metadata such as info, position, and (optionally) the current steady-state mass_flow.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.NodeCommon","page":"Nodes and Edges","title":"DHNetworkSimulator.NodeCommon","text":"Common data for all node types in the DH network.\n\nNodeCommon contains fields that are useful across producers, junctions, and loads.\n\nmutable struct NodeCommon\n    info::String\n    position::Union{Missing, Tuple{Float64, Float64}}   # (x, y) coordinates\n    mass_flow::Union{Missing, Float64}                  # [kg/s]\nend\n\nFields\n\ninfo::String: human-readable label shown in printing/plots.\nposition::Union{Missing, Tuple{Float64, Float64}}: optional (x,y) coordinates (used by visualization).\nmass_flow::Union{Missing, Float64}: steady-state mass flow through the node in kg/s.\n\nNotes\n\nMany fields use missing to represent “not initialized / not computed yet”.\nDuring simulation, mass flows are usually filled by steady_state_hydronynamics!.\n\nConstructors\n\nNodeCommon(info::String)\nNodeCommon(info::String, position::Tuple{Float64, Float64})\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.JunctionNode","page":"Nodes and Edges","title":"DHNetworkSimulator.JunctionNode","text":"DH network node representing a junction.\n\nJunctions are internal vertices that connect multiple pipes but do not directly produce or consume heat. They are where flow splits (supply direction) or merges (return direction).\n\nstruct JunctionNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nJunctionNode(info::String)\nJunctionNode(info::String, position::Tuple{Float64, Float64})\nJunctionNode(position::Tuple{Float64, Float64})\nJunctionNode()\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.LoadNode","page":"Nodes and Edges","title":"DHNetworkSimulator.LoadNode","text":"DH network node representing a load (consumer).\n\nThe load field defines a quadratic power-demand curve as a function of ambient temperature T_a:\n\nP(T_a) = p_0 + p_1 T_a + p_2 T_a^2 where the power is in kW and the ambient temperature is in °C.\n\nThe m_rel field is a relative mass-flow coefficient used when splitting flows at a junction while solving steady state flow; it is specified for leaf nodes and propagated to upstream edges.\n\nmutable struct LoadNode <: NodeType\n    common::NodeCommon\n    load::Union{Missing, NTuple{3, Float64}}     # Heat load function in kW, P(Tₐ) = p₀ + p₁*Tₐ + p₂*Tₐ²\n    m_rel::Union{Missing, Float64}               # Relative mass flow coefficient (for branching nodes)\nend\n\nConstructors\n\nLoadNode(info::String; load=DEFAULT_LOAD): Creates a LoadNode with the specified info string and an optional load function (default is a typical load curve).\nLoadNode(info::String, position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(info::String, position::Tuple{Float64, Float64}, load::NTuple{3, Float64})\nLoadNode(info::String, position::Tuple{Float64, Float64}, m_rel::Float64; load=DEFAULT_LOAD)\nLoadNode(position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(; load=DEFAULT_LOAD)\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.ProducerNode","page":"Nodes and Edges","title":"DHNetworkSimulator.ProducerNode","text":"DH network node representing a producer (heat source).\n\nThere may be only one producer in the network, and it is identified by its label (producer_label field in Network).\n\nIn simulations, the producer’s mass flow and supply temperature are usually provided by a control policy (see ProducerOutput and run_simulation).\n\nstruct ProducerNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nProducerNode(info::String)\nProducerNode(info::String, position::Tuple{Float64, Float64})\nProducerNode(position::Tuple{Float64, Float64})\nProducerNode()\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyNode","page":"Nodes and Edges","title":"DHNetworkSimulator.EmptyNode","text":"Placeholder node type.\n\nEmptyNode is used when constructing a Network from a bare topology (e.g. Network(graph::DiGraph)). Replace placeholders with real node types (ProducerNode, JunctionNode, LoadNode) before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EdgeType","page":"Nodes and Edges","title":"DHNetworkSimulator.EdgeType","text":"Abstract supertype for all edge types in a district heating network.\n\nEdges represent physical connections between nodes. In this package the primary edge type is InsulatedPipe. EmptyEdge is used as a placeholder (e.g., when building a network from a bare topology).\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyEdge","page":"Nodes and Edges","title":"DHNetworkSimulator.EmptyEdge","text":"Placeholder edge type.\n\nEmptyEdge is used when constructing a Network from a topology without pipe parameters. Replace it with InsulatedPipe before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.Plug","page":"Nodes and Edges","title":"DHNetworkSimulator.Plug","text":"A single water plug used by the plug-method pipe model.\n\nA Plug represents a mass of water inside a pipe that is assumed to have uniform temperature. Plugs are advected through pipes during time stepping and may be split/merged.\n\nmutable struct Plug\n    T::Float64  # Temperature at the plug [°C]\n    m::Float64  # mass of the plug [kg]\nend\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.InsulatedPipe","page":"Nodes and Edges","title":"DHNetworkSimulator.InsulatedPipe","text":"DH network edge representing an insulated pipe.\n\nInsulatedPipe transports water between nodes and stores both physical parameters and the current hydraulic/thermal state.\n\nmutable struct InsulatedPipe <: EdgeType\n    info::String\n    physical_params::PipeParams\n    mass_flow::Union{Missing, Float64}  # Mass flow in [kg/s]\n    m_rel::Union{Missing, Float64}      # Relative mass flow coefficient (for branching pipes)\n    plugs_f::Vector{Plug}               # Queue of plugs in the pipe (forward direction)\n    plugs_b::Vector{Plug}               # Queue of plugs in the pipe (backward direction)\nend\n\nFields\n\n`physical_params: geometry and heat-loss parameters.\nmass_flow: mass flow in kg/s (typically computed bysteadystatehydronynamics!`).\n`m_rel: relative flow coefficient used for splitting at junctions.\n`plugs_f: plug queue for the forward (supply) direction.\n`plugs_b: plug queue for the backward (return) direction.\n\nConstructors\n\nInsulatedPipe(info::String; length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nInsulatedPipe(info::String, params::PipeParams)\nInsulatedPipe(params::PipeParams)\nInsulatedPipe(length::Real)\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.PipeParams","page":"Nodes and Edges","title":"DHNetworkSimulator.PipeParams","text":"Physical parameters of a pipe (constant during simulation).\n\nThese parameters describe geometry and heat-loss characteristics.\n\nstruct PipeParams                       # unchanging physical parameters of the pipe\n    length::Float64                     # Length of the pipe [m]\n    inner_diameter::Float64             # Inner diameter [m]\n    heat_resistance_forward::Float64    # Thermal resistance [m*K/W]\n    heat_resistance_backward::Float64   # Thermal resistance [m*K/W]\nend\n\nFields\n\nlength [m]\ninner_diameter [m]\nheat_resistance_forward [m·K/W]: thermal resistance for the supply direction\nheat_resistance_backward [m·K/W]: thermal resistance for the return direction\n\nConstructors\n\nPipeParams(length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nPipeParams(length::Float64, inner_diameter::Float64): uses default heat resistance values based on typical insulation properties.\n\n\n\n\n\n","category":"type"}]
}
