var documenterSearchIndex = {"docs":
[{"location":"Plug_method/#Plug-method","page":"Plug method","title":"Plug method","text":"One of the ways to solve thermo-dynamics with hydraulics.\n\nThis project solves heat transport in a district heating network using a plug-flow (parcel) method. Each pipe contains a queue of discrete plugs of water, where every plug has:\n\ntemperature T [°C]\nmass m [kg]\n\nPlugs advect through pipes according to the current mass flows, exchange heat with the environment via a simple heat-loss model, and (optionally) lose heat at loads according to the load power demand.\n\nThe implementation lives primarily in:\n\nsrc/types.jl (type Plug and pipe storage plugs_f / plugs_b)\nsrc/simulation.jl (time_step_thermal_dynamics_forward!, time_step_thermal_dynamics_backward!)","category":"section"},{"location":"Plug_method/#Why-plugs?","page":"Plug method","title":"Why plugs?","text":"The approach is based on a quasi-dynamic assumption:\n\nHydraulics (mass flow distribution) is assumed to reach steady state “instantaneously” compared to\nThermal dynamics, which are dominated by advection (transport of hot water) and slow heat losses.\n\nAs a result, each simulation time step does:\n\ncompute steady-state mass flows (steady_state_hydronynamics!)\ntransport heat by moving plugs\nforward (supply) direction: from producer to loads\nheat extraction at loads: using a power-demand model (often based on outdoor-temperature compensation, sometimes called equithermal regulation)\nbackward (return) direction: from loads back to the producer","category":"section"},{"location":"Plug_method/#State-representation","page":"Plug method","title":"State representation","text":"Each pipe edge represents two pipes and therefore stores two independent plug queues:\n\nplugs_f: plugs moving in the forward/supply direction\nplugs_b: plugs moving in the backward/return direction\n\nWithin a pipe, plugs are treated as non-mixing parcels (no axial mixing). Mixing is handled explicitly only where the network topology merges/splits flow.","category":"section"},{"location":"Plug_method/#One-simulation-time-step-(high-level)","page":"Plug method","title":"One simulation time step (high level)","text":"For each time step of length Δt:\n\nInsert new hot plugs at the producer into each outgoing supply pipe.\nForward pass (supply): move plugs from producer to loads using current mass flows.\nLoads: compute required power P(T_a) from ambient temperature and cool the arriving plug accordingly.\nBackward pass (return): push cooled plugs back to the producer, mixing at junctions as needed.\nHeat losses to ambient: cool all plugs remaining in pipes (supply and return) using an exponential heat-loss model.\n\nThe overall simulation loop is orchestrated by run_simulation.\n\n","category":"section"},{"location":"Plug_method/#Forward-pass-(supply):-advection-and-splitting","page":"Plug method","title":"Forward pass (supply): advection and splitting","text":"","category":"section"},{"location":"Plug_method/#1)-Plug-injection-at-the-source","page":"Plug method","title":"1) Plug injection at the source","text":"For each outgoing edge from the producer, a new plug is created with:\n\nm_in = dot mDelta t\n\nand temperature equal to the producer outlet temperature for that step. The plug is appended to that pipe’s forward queue.","category":"section"},{"location":"Plug_method/#2)-Plug-advection-through-a-pipe","page":"Plug method","title":"2) Plug advection through a pipe","text":"For a pipe with mass flow dot m, the algorithm computes the mass that must exit the pipe in this step:\n\nm_out = dot mDelta t\n\nIt then pops plugs from the front of the queue until the exiting mass is reached. If a plug is larger than the remaining mass to exit, it is split into an exiting part and a remaining part.\n\nThis is implemented by collect_exiting_water_plugs!.","category":"section"},{"location":"Plug_method/#3)-Junction-splitting-(tree)","page":"Plug method","title":"3) Junction splitting (tree)","text":"When a node has multiple children, the exiting plug mass is split among outgoing edges proportional to edge mass flows:\n\nm_child = m_plugfracdot m_childsum_k dot m_k\n\nEach child receives a new plug with the same temperature and the computed mass. These plugs are appended to the child edges’ forward queues.","category":"section"},{"location":"Plug_method/#4)-Leaf-handling-(load-inlet-plug)","page":"Plug method","title":"4) Leaf handling (load inlet plug)","text":"At a leaf node, all plugs that arrive during the step are combined into a single representative plug using a mass-weighted average:\n\nT_avg = fracsum_i T_i m_isum_i m_i\n\nThis is implemented by combine_plugs.\n\nThe resulting plug is interpreted as the supply plug entering the load for this time step.\n\n","category":"section"},{"location":"Plug_method/#Load-model:-consuming-heat","page":"Plug method","title":"Load model: consuming heat","text":"Each load node computes power demand based on ambient temperature T_a (we use a 2nd-order polynomial approximation):\n\nP = P(T_a) = p_1 + p_2 T_a + p_3 T_a^2\n\nThe entering plug is cooled by energy extraction over the step:\n\nDelta T = fracPDelta tmc_p\n\nso the return-side plug temperature becomes T - Delta T.\n\nTo avoid unphysical results (like cooling the plug to lower temperature than is inside the building), the implementation clamps return temperature to a configured minimal value (MINIMAL_RETURN_TEMPERATURE = 25.0).\n\n","category":"section"},{"location":"Plug_method/#Backward-pass-(return):-advection-and-merging","page":"Plug method","title":"Backward pass (return): advection and merging","text":"The backward pass pushes the cooled plugs from loads back to the producer using the return queues plugs_b.","category":"section"},{"location":"Plug_method/#Leaf-injection","page":"Plug method","title":"Leaf injection","text":"At each load (leaf), the cooled plug is pushed into the parent edge’s return queue.","category":"section"},{"location":"Plug_method/#Junction-merging","page":"Plug method","title":"Junction merging","text":"At an internal node, return plugs are collected from each child return edge (again using collect_exiting_water_plugs!). These multiple plug sequences must be merged into a single sequence going into the parent.\n\nThe code uses merge_water_plug_vectors!, which mixes the plugs according to the individual flows in merging pipes.\n\nAt the producer root, the merged plug sequence is combined to a single plug representing the return temperature entering the producer for that step.\n\n","category":"section"},{"location":"Plug_method/#Heat-loss-to-ambient-(dissipation-to-atmosphere)","page":"Plug method","title":"Heat loss to ambient (dissipation to atmosphere)","text":"After advection, both in forward and backward pass, the remaining plugs in pipes are cooled to account for heat loss to the environment.\n\nFor each plug, temperature is updated using an exponential model:\n\nT_next = T_a + (T - T_a)expleft(-fracDelta trho c_p A Rright)\n\nwhere:\n\nrho is water density (WATER_DENSITY)\nc_p is specific heat (WATER_SPECIFIC_HEAT)\nA is cross-sectional area of the pipe A = pi(fracd2)^2\nR is pipe thermal resistance ... this is given by pipe insulation and usually differs for forward and backward pass\n\n","category":"section"},{"location":"Plug_method/#Practical-notes-and-limitations","page":"Plug method","title":"Practical notes and limitations","text":"The current network traversal assumes a directed tree (each non-root node has one parent).\nThere is no axial mixing inside a pipe: plugs only merge when explicitly combined (e.g., at reporting points or junction return merging).\nThe plug representation is simplified over time by merging consecutive plugs with nearly identical temperature (merge_same_temperature_plugs!).\nStability and realism depend on choosing a reasonable Δt relative to flows and pipe volumes.","category":"section"},{"location":"Network/#Network","page":"Network","title":"Network","text":"Network is the main model type in DHNetworkSimulator. It represents a district heating network as a directed graph:\n\nwater flows from one producer (the source/root),\nthrough optional junctions (branching/merging points),\nto multiple loads (consumers, typically leaves).\n\nUnlike a plain graph, a Network stores typed domain data on:\n\nnodes: ProducerNode, JunctionNode, LoadNode (plus EmptyNode as a placeholder during construction),\nedges: typically InsulatedPipe (plus EmptyEdge as a placeholder during construction).\nmore on nodes and edges in Network nodes and edges\n\nThis design makes it straightforward to build a topology, attach physical parameters, and run the hydraulic + thermal simulation.","category":"section"},{"location":"Network/#What-It-Stores","page":"Network","title":"What It Stores","text":"","category":"section"},{"location":"Network/#Features","page":"Network","title":"Features","text":"","category":"section"},{"location":"Network/#MetaGraph","page":"Network","title":"MetaGraph","text":"For the internal graph structure we use MetaGraph MetaGraphNext.jl, because it is type stable (not like MetaGraphs.jl). We prefer it over Graphs.jl for 2 main reasons:\n\ngraph from Graphs.jl has not stable indexing: when a node is removed, all the nodes are reindexed so that there are no gaps in indexing. For example we have graph with three vertices {V[1], V[2], V[3]}. If we remove the middle vertex V[2], the vertex V[3]'s indexing is changed to be V[2]. On the other hand, if we remove vertex V[B] from metagraph {V[A], V[B], V[C]}, the indexing (or rather labeling) stays the same and we get {V[A], V[C]}\nMetaGraph lets us store node/edge data on the vertices/edges.","category":"section"},{"location":"Network/#Indexing-by-Labels","page":"Network","title":"Indexing by Labels","text":"Nodes and edges are addressed by string labels:\n\nnw[\"A\"] returns the node data for label \"A\".\nnw[\"A\", \"B\"] returns the edge data from \"A\" to \"B\".\n\nBecause Network subtypes AbstractGraph, you can also use Graphs.jl-style APIs such as nv, ne, vertices, and edges.\n\nwarning: Graphs.jl indices vs MetaGraphNext labels\nFunctions like vertices, edges, src(e), dst(e) from Graphs.jl give you vertex indices from the underlying graph. To convert an index back to a label, use label_for(nw, idx).","category":"section"},{"location":"Network/#Structural-Assumptions-(Validated-at-Simulation-Start)","page":"Network","title":"Structural Assumptions (Validated at Simulation Start)","text":"The simulator assumes the network is static during a run (topology does not change while stepping). Before simulation starts, DHNetworkSimulator validates that:\n\nthere is exactly one producer node (producer_label must be set),\nthe directed graph is acyclic,\nthe graph is connected (all nodes are reachable from the producer),\nload nodes are leaves (outdegree 0).\n\nrun_simulation calls check_network! internally before the first step, which does all of that, no need to do it yourself.","category":"section"},{"location":"Network/#Neighbor-Caching-(NeighborDicts)","page":"Network","title":"Neighbor Caching (NeighborDicts)","text":"Thermal and hydraulic stepping frequently calls outneighbors(nw, label) and inneighbors(nw, label). To reduce allocations and repeated work, Network maintains cached neighbor lists in NeighborDicts:\n\nWhen you modify the network structure (add/remove/rename nodes or edges), the cache is marked dirty. It is rebuilt automatically when needed (for example in run_simulation via check_network!). Also simple call outneighbors(network,label) makes the cache update if marked dirty.","category":"section"},{"location":"Network/#Typical-Workflows","page":"Network","title":"Typical Workflows","text":"","category":"section"},{"location":"Network/#1)-Create-a-Network-From-a-Graph-Topology","page":"Network","title":"1) Create a Network From a Graph Topology","text":"Use this when the topology already exists (e.g., imported from data or generated programmatically) and you want to attach node/edge data afterward.\n\nusing DHNetworkSimulator\nusing Graphs\n\n# 1 -> 2 -> 3, and 2 -> 4\ng = DiGraph(4)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 2, 4)\n\nnw = Network(g)\nname_nodes!(nw, [\"P\", \"J\", \"L1\", \"L2\"]) # rename 1..n to meaningful labels\nidentify_producer_and_loads!(nw)            # assign Producer/Junction/Load node types\n\n# attach pipe parameters (edge data)\nnw[\"P\", \"J\"]  = InsulatedPipe(\"P→J\";  length=300.0, inner_diameter=0.10)\nnw[\"J\", \"L1\"] = InsulatedPipe(\"J→L1\"; length=150.0, inner_diameter=0.08)\nnw[\"J\", \"L2\"] = InsulatedPipe(\"J→L2\"; length=180.0, inner_diameter=0.08)\n\nne(nw), nv(nw)\n\nWe can also display all sorts of info about the network:\n\njulia> nw\nDH Network:\n Number of nodes: 4\n Number of edges: 3\n Producer node: P\n Load nodes (2): {L1, L2}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] L1 : Load Node, Info: L1, Load (at 0°C): 540.0 kW\n[2] P : Producer Node, Info: P\n[3] J : Junction Node, Info: J\n[4] L2 : Load Node, Info: L2, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[2] P -->  [3] J : Pipe Edge, L=300.0, D_in=0.1, R_f=3.0, R_b=4.0\n[3] J -->  [1] L1 : Pipe Edge, L=150.0, D_in=0.08, R_f=3.0, R_b=4.0\n[3] J -->  [4] L2 : Pipe Edge, L=180.0, D_in=0.08, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#2)-Build-a-Small-Network-Manually","page":"Network","title":"2) Build a Small Network Manually","text":"For quick experiments you can start from Network() and assign nodes/edges directly by label.\n\nusing DHNetworkSimulator\n\nnw = Network()\nnw[\"P\"]  = ProducerNode(\"Plant\", (0.0, 0.0))\nnw[\"L1\"] = LoadNode(\"House 1\", (1.0, 0.0))\n\nnw[\"P\", \"L1\"] = InsulatedPipe(\"P→L1\"; length=200.0, inner_diameter=0.10)\n\njulia> nw\nDH Network:\n Number of nodes: 2\n Number of edges: 1\n Producer node: P\n Load nodes (1): {L1}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] P : Producer Node, Info: Plant\n[2] L1 : Load Node, Info: House 1, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[1] P -->  [2] L1 : Pipe Edge, L=200.0, D_in=0.1, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#Network-visualization","page":"Network","title":"Network visualization","text":"Visualization (plotting) of network is another feature that will come in handy. We can pan, zoom and if we hover over an edge, it turns red and additional info is shown.\n\nBy calling visualize_graph!(network) we get Makies display of our network.\n\nBlue nodes are loads, green is producer, black lines are pipes. The thicker the line, the bigger the pipe.\n\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz1)\n\nIf there is computed steady state flow first, the visualization shows the flow in the edges as well. The darker the more flow there is, which makes easy to analyze turbulance. Also, additional info is written in labels next to the edges and the exact flow velocity in [m/s] is shown upon hover.\n\nsteady_state_hydronynamics!(network, 100.0)\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz2)","category":"section"},{"location":"Network/#When-to-Use-Network","page":"Network","title":"When to Use Network","text":"Network is intended for modeling and simulation tasks such as:\n\nControl and policy studies: define a policy(t, Tₐ, T_back) callback and see how actions affect supply/return temperatures.\nDesign what-ifs: change pipe parameters and compare temperature drops, delays, and load satisfaction.\nTopology experiments: evaluate different branching structures and relative flow splits.\nVisualization & debugging: inspect the graph, pipe information, and computed flows.","category":"section"},{"location":"Network/#DHNetworkSimulator.Network","page":"Network","title":"DHNetworkSimulator.Network","text":"Network type representing a district heating network.\n\nmutable struct Network{T<:Integer} <: AbstractGraph{T}\n    mg::MetaGraph                               # MetaGraph from MetaGraphs.jl, it contains the network \n                                                    structure and node and edge data\n    producer_label::Union{Nothing, String}      # Label of the producer node\n    load_labels::Set{String}                    # Labels of the consumer nodes\n    neighbor_dicts::NeighborDicts               # Mappings to inneghbors and outneighbors for efficient access during simulation\nend\n\nFields\n\nmg: a MetaGraphsNext MetaGraph that contains the directed topology and stores node/edge data.\nproducer_label: label of the single producer node (or nothing if not yet set).\nload_labels: a set of labels for load nodes.\nneighbor_dicts: cached neighbor lists used to reduce allocations during simulation.\n\nConstructors\n\nNetwork(): Creates an empty DH network with no nodes or edges.\nNetwork(g::DiGraph): Creates a DH network from an existing directed graph structure ('Graphs.jl').                        Nodes and edges are initialized with EmptyNode and EmptyEdge data.\n\n\n\n\n\n","category":"type"},{"location":"Network/#DHNetworkSimulator.NeighborDicts","page":"Network","title":"DHNetworkSimulator.NeighborDicts","text":"Mappings to inneghbors and outneighbors for efficient access during simulation, stored in the Network struct.\n\nWhen calling functions outneighbors(nw, label) or inneighbors(nw, label),  there is no need to scan through the graph and collect neighbors,  instead we can directly access the pre-computed neighbor lists in the dictionaries. This significantly lowers the number of allocations during simulation, because there is a lot of places where we need to access neighbors of a node.\n\nThe network is static during the simulation, so we can compute these neighbor lists once before the simulation starts and then reuse them.\n\nmutable struct NeighborDicts\n    outneighbors::Dict{String, Vector{String}}       # mapping nodes to outneighbors for efficient access in simulation\n    inneighbors::Dict{String, Vector{String}}        # mapping nodes to inneighbors for efficient access in simulation\n    need_rebuild::Bool                               # flag to indicate if neighbor dicts need to be rebuilt before simulation\nend\n\nneed_rebuild flag is used to indicate when the neighbor dicts need to be updated  (e.g., after adding/removing nodes or edges), so that we can avoid unnecessary   rebuilding during multiple modifications.\n\nConstructor\n\nNeighborDicts(): Creates an instance of NeighborDicts with empty dictionaries and the need_rebuild flag set to true.\n\n\n\n\n\n","category":"type"},{"location":"#Distributed-Heating-Network-Simulator","page":"Distributed Heating Network Simulator","title":"Distributed Heating Network Simulator","text":"This is the Documentation for DHNetworkSimulator.\n\nDHNetworkSimulator is a Julia package for building, visualizing, and simulating district heating networks. Network is represented as directed tree graph, root node is producer and leaf are consumers (loads).\n\nThermodynamics is solved using quazi-dynamic assumption, which makes the problem tractable. The assumption is that hydraulics (change in flow, pressures) has frequency much higher than thermics (change in temperature). In simple words, pressure moves in water with speed of sound and temperature moves mainly with advection (the hot water itself moves).\n\nWe solve the dynamics in two steps:\n\nfind steady state of hydraulics\nsolve thermics by moving \"plugs\" of water. Consecutive plugs dont mix.\n\nMore on plug method in Plug method.\n\nsmall change","category":"section"},{"location":"#Getting-started","page":"Distributed Heating Network Simulator","title":"Getting started","text":"To install the package, open the Julia REPL and type\n\njulia> using Pkg; Pkg.add(\"https://github.com/PajaS22/DHNetworkSimulator\")","category":"section"},{"location":"#Examples","page":"Distributed Heating Network Simulator","title":"Examples","text":"The easiest way to get a feel for the API is to run one of the example scripts.\n\nscripts/basic_network.jl\nscripts/bigger_network.jl","category":"section"},{"location":"#Minimal-example-(policy-driven-simulation)","page":"Distributed Heating Network Simulator","title":"Minimal example (policy-driven simulation)","text":"run_simulation takes a network, a time vector, and a policy(t, Tₐ, T_back) callback that returns a ProducerOutput. Simulation than returns SimulationResults struct holding  time series of many physical variables of the network.\n\nusing DHNetworkSimulator\n\nnetwork = Network()\nnetwork[\"producer\"] = ProducerNode((0.0, 0.0))\n\n# ... add junctions/loads/pipes here ...\n\nt = collect(0.0:60.0:3*3600.0) # seconds\n\nfunction policy(t, Tₐ, T_back) # constant flow and temperature\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n# set initial temperatures in pipes to 75°C and 60°C\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\n# plot temperature of water entering loads\nplot_simulation_results(results, :T_load_in)","category":"section"},{"location":"types/#Network-nodes-and-edges","page":"Network nodes and edges","title":"Network nodes and edges","text":"This page documents the core data types used to represent a district heating network.\n\nThe package models a network as a directed graph where:\n\nvertices are nodes (ProducerNode, JunctionNode, LoadNode), and\nedges are pipes (InsulatedPipe) carrying water plugs.","category":"section"},{"location":"types/#Conventions","page":"Network nodes and edges","title":"Conventions","text":"Temperatures are in °C.\nMass flow is in kg/s.\nPipe lengths are in m, inner diameters in m.\nPower demand curves in LoadNode use coefficients in kW.\n\nnote: `missing` means not initialized\nMany fields use missing to represent “not set” or “not computed yet”. For example, mass_flow is typically filled during the steady-state hydraulics step.","category":"section"},{"location":"types/#Nodes","page":"Network nodes and edges","title":"Nodes","text":"","category":"section"},{"location":"types/#Edges","page":"Network nodes and edges","title":"Edges","text":"","category":"section"},{"location":"types/#DHNetworkSimulator.NodeType","page":"Network nodes and edges","title":"DHNetworkSimulator.NodeType","text":"Abstract supertype for all node types in a district heating network.\n\nConcrete node types describe the role of a vertex in the directed network:\n\nProducerNode: heat source (root)\nJunctionNode: branching/merging point\nLoadNode: heat consumer (typically a leaf)\nEmptyNode: placeholder used during construction\n\nAll concrete node types store a common::NodeCommon field with metadata such as info, position, and (optionally) the current steady-state mass_flow.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.NodeCommon","page":"Network nodes and edges","title":"DHNetworkSimulator.NodeCommon","text":"Common data for all node types in the DH network.\n\nNodeCommon contains fields that are useful across producers, junctions, and loads.\n\nmutable struct NodeCommon\n    info::String\n    position::Union{Missing, Tuple{Float64, Float64}}   # (x, y) coordinates\n    mass_flow::Union{Missing, Float64}                  # [kg/s]\nend\n\nFields\n\ninfo::String: human-readable label shown in printing/plots.\nposition::Union{Missing, Tuple{Float64, Float64}}: optional (x,y) coordinates (used by visualization).\nmass_flow::Union{Missing, Float64}: steady-state mass flow through the node in kg/s.\n\nNotes\n\nMany fields use missing to represent “not initialized / not computed yet”.\nDuring simulation, mass flows are usually filled by steady_state_hydronynamics!.\n\nConstructors\n\nNodeCommon(info::String)\nNodeCommon(info::String, position::Tuple{Float64, Float64})\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.JunctionNode","page":"Network nodes and edges","title":"DHNetworkSimulator.JunctionNode","text":"DH network node representing a junction.\n\nJunctions are internal vertices that connect multiple pipes but do not directly produce or consume heat. They are where flow splits (supply direction) or merges (return direction).\n\nstruct JunctionNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nJunctionNode(info::String)\nJunctionNode(info::String, position::Tuple{Float64, Float64})\nJunctionNode(position::Tuple{Float64, Float64})\nJunctionNode()\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.LoadNode","page":"Network nodes and edges","title":"DHNetworkSimulator.LoadNode","text":"DH network node representing a load (consumer).\n\nThe load field defines a quadratic power-demand curve as a function of ambient temperature T_a:\n\nP(T_a) = p_0 + p_1 T_a + p_2 T_a^2 where the power is in kW and the ambient temperature is in °C.\n\nThe m_rel field is a relative mass-flow coefficient used when splitting flows at a junction while solving steady state flow; it is specified for leaf nodes and propagated to upstream edges.\n\nmutable struct LoadNode <: NodeType\n    common::NodeCommon\n    load::Union{Missing, NTuple{3, Float64}}     # Heat load function in kW, P(Tₐ) = p₀ + p₁*Tₐ + p₂*Tₐ²\n    m_rel::Union{Missing, Float64}               # Relative mass flow coefficient (for branching nodes)\nend\n\nConstructors\n\nLoadNode(info::String; load=DEFAULT_LOAD): Creates a LoadNode with the specified info string and an optional load function (default is a typical load curve).\nLoadNode(info::String, position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(info::String, position::Tuple{Float64, Float64}, load::NTuple{3, Float64})\nLoadNode(info::String, position::Tuple{Float64, Float64}, m_rel::Float64; load=DEFAULT_LOAD)\nLoadNode(position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(; load=DEFAULT_LOAD)\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.ProducerNode","page":"Network nodes and edges","title":"DHNetworkSimulator.ProducerNode","text":"DH network node representing a producer (heat source).\n\nThere may be only one producer in the network, and it is identified by its label (producer_label field in Network).\n\nIn simulations, the producer’s mass flow and supply temperature are usually provided by a control policy (see ProducerOutput and run_simulation).\n\nstruct ProducerNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nProducerNode(info::String)\nProducerNode(info::String, position::Tuple{Float64, Float64})\nProducerNode(position::Tuple{Float64, Float64})\nProducerNode()\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyNode","page":"Network nodes and edges","title":"DHNetworkSimulator.EmptyNode","text":"Placeholder node type.\n\nEmptyNode is used when constructing a Network from a bare topology (e.g. Network(graph::DiGraph)). Replace placeholders with real node types (ProducerNode, JunctionNode, LoadNode) before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EdgeType","page":"Network nodes and edges","title":"DHNetworkSimulator.EdgeType","text":"Abstract supertype for all edge types in a district heating network.\n\nEdges represent physical connections between nodes. In this package the primary edge type is InsulatedPipe. EmptyEdge is used as a placeholder (e.g., when building a network from a bare topology).\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyEdge","page":"Network nodes and edges","title":"DHNetworkSimulator.EmptyEdge","text":"Placeholder edge type.\n\nEmptyEdge is used when constructing a Network from a topology without pipe parameters. Replace it with InsulatedPipe before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.Plug","page":"Network nodes and edges","title":"DHNetworkSimulator.Plug","text":"A single water plug used by the plug-method pipe model.\n\nA Plug represents a mass of water inside a pipe that is assumed to have uniform temperature. Plugs are advected through pipes during time stepping and may be split/merged.\n\nmutable struct Plug\n    T::Float64  # Temperature at the plug [°C]\n    m::Float64  # mass of the plug [kg]\nend\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.InsulatedPipe","page":"Network nodes and edges","title":"DHNetworkSimulator.InsulatedPipe","text":"DH network edge representing an insulated pipe.\n\nInsulatedPipe transports water between nodes and stores both physical parameters and the current hydraulic/thermal state.\n\nmutable struct InsulatedPipe <: EdgeType\n    info::String\n    physical_params::PipeParams\n    mass_flow::Union{Missing, Float64}  # Mass flow in [kg/s]\n    m_rel::Union{Missing, Float64}      # Relative mass flow coefficient (for branching pipes)\n    plugs_f::Vector{Plug}               # Queue of plugs in the pipe (forward direction)\n    plugs_b::Vector{Plug}               # Queue of plugs in the pipe (backward direction)\nend\n\nFields\n\n`physical_params: geometry and heat-loss parameters.\nmass_flow: mass flow in kg/s (typically computed bysteadystatehydronynamics!`).\n`m_rel: relative flow coefficient used for splitting at junctions.\n`plugs_f: plug queue for the forward (supply) direction.\n`plugs_b: plug queue for the backward (return) direction.\n\nConstructors\n\nInsulatedPipe(info::String; length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nInsulatedPipe(info::String, params::PipeParams)\nInsulatedPipe(params::PipeParams)\nInsulatedPipe(length::Real)\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.PipeParams","page":"Network nodes and edges","title":"DHNetworkSimulator.PipeParams","text":"Physical parameters of a pipe (constant during simulation).\n\nThese parameters describe geometry and heat-loss characteristics.\n\nstruct PipeParams                       # unchanging physical parameters of the pipe\n    length::Float64                     # Length of the pipe [m]\n    inner_diameter::Float64             # Inner diameter [m]\n    heat_resistance_forward::Float64    # Thermal resistance [m*K/W]\n    heat_resistance_backward::Float64   # Thermal resistance [m*K/W]\nend\n\nFields\n\nlength [m]\ninner_diameter [m]\nheat_resistance_forward [m·K/W]: thermal resistance for the supply direction\nheat_resistance_backward [m·K/W]: thermal resistance for the return direction\n\nConstructors\n\nPipeParams(length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nPipeParams(length::Float64, inner_diameter::Float64): uses default heat resistance values based on typical insulation properties.\n\n\n\n\n\n","category":"type"}]
}
