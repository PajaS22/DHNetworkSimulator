var documenterSearchIndex = {"docs":
[{"location":"Plug_method/#Plug-method","page":"Plug method","title":"Plug method","text":"One of the ways to solve thermo-dynamics with hydraulics.\n\nThis project solves heat transport in a district heating network using a plug-flow (parcel) method. Each pipe contains a queue of discrete plugs of water, where every plug has:\n\ntemperature T [°C]\nmass m [kg]\n\nPlugs advect through pipes according to the current mass flows, exchange heat with the environment via a simple heat-loss model, and (optionally) lose heat at loads according to the load power demand.\n\nThe implementation lives primarily in:\n\nsrc/types.jl (type Plug and pipe storage plugs_f / plugs_b)\nsrc/simulation.jl (time_step_thermal_dynamics_forward!, time_step_thermal_dynamics_backward!)","category":"section"},{"location":"Plug_method/#Why-plugs?","page":"Plug method","title":"Why plugs?","text":"The approach is based on a quasi-dynamic assumption:\n\nHydraulics (mass flow distribution) is assumed to reach steady state “instantaneously” compared to\nThermal dynamics, which are dominated by advection (transport of hot water) and slow heat losses.\n\nAs a result, each simulation time step does:\n\ncompute steady-state mass flows (steady_state_hydronynamics!)\ntransport heat by moving plugs\nforward (supply) direction: from producer to loads\nheat extraction at loads: using a power-demand model (often based on outdoor-temperature compensation, sometimes called equithermal regulation)\nbackward (return) direction: from loads back to the producer","category":"section"},{"location":"Plug_method/#State-representation","page":"Plug method","title":"State representation","text":"Each pipe edge represents two pipes and therefore stores two independent plug queues:\n\nplugs_f: plugs moving in the forward/supply direction\nplugs_b: plugs moving in the backward/return direction\n\nWithin a pipe, plugs are treated as non-mixing parcels (no axial mixing). Mixing is handled explicitly only where the network topology merges/splits flow.","category":"section"},{"location":"Plug_method/#One-simulation-time-step-(high-level)","page":"Plug method","title":"One simulation time step (high level)","text":"For each time step of length Δt:\n\nInsert new hot plugs at the producer into each outgoing supply pipe.\nForward pass (supply): move plugs from producer to loads using current mass flows.\nLoads: compute required power P(T_a) from ambient temperature and cool the arriving plug accordingly.\nBackward pass (return): push cooled plugs back to the producer, mixing at junctions as needed.\nHeat losses to ambient: cool all plugs remaining in pipes (supply and return) using an exponential heat-loss model.\n\nThe overall simulation loop is orchestrated by run_simulation.\n\n","category":"section"},{"location":"Plug_method/#Forward-pass-(supply):-advection-and-splitting","page":"Plug method","title":"Forward pass (supply): advection and splitting","text":"","category":"section"},{"location":"Plug_method/#1)-Plug-injection-at-the-source","page":"Plug method","title":"1) Plug injection at the source","text":"For each outgoing edge from the producer, a new plug is created with:\n\nm_in = dot mDelta t\n\nand temperature equal to the producer outlet temperature for that step. The plug is appended to that pipe’s forward queue.","category":"section"},{"location":"Plug_method/#2)-Plug-advection-through-a-pipe","page":"Plug method","title":"2) Plug advection through a pipe","text":"For a pipe with mass flow dot m, the algorithm computes the mass that must exit the pipe in this step:\n\nm_out = dot mDelta t\n\nIt then pops plugs from the front of the queue until the exiting mass is reached. If a plug is larger than the remaining mass to exit, it is split into an exiting part and a remaining part.\n\nThis is implemented by collect_exiting_water_plugs!.","category":"section"},{"location":"Plug_method/#3)-Junction-splitting-(tree)","page":"Plug method","title":"3) Junction splitting (tree)","text":"When a node has multiple children, the exiting plug mass is split among outgoing edges proportional to edge mass flows:\n\nm_child = m_plugfracdot m_childsum_k dot m_k\n\nEach child receives a new plug with the same temperature and the computed mass. These plugs are appended to the child edges’ forward queues.","category":"section"},{"location":"Plug_method/#4)-Leaf-handling-(load-inlet-plug)","page":"Plug method","title":"4) Leaf handling (load inlet plug)","text":"At a leaf node, all plugs that arrive during the step are combined into a single representative plug using a mass-weighted average:\n\nT_avg = fracsum_i T_i m_isum_i m_i\n\nThis is implemented by combine_plugs.\n\nThe resulting plug is interpreted as the supply plug entering the load for this time step.\n\n","category":"section"},{"location":"Plug_method/#Load-model:-consuming-heat","page":"Plug method","title":"Load model: consuming heat","text":"Each load node computes power demand based on ambient temperature T_a (we use a 2nd-order polynomial approximation):\n\nP = P(T_a) = p_1 + p_2 T_a + p_3 T_a^2\n\nThe entering plug is cooled by energy extraction over the step:\n\nDelta T = fracPDelta tmc_p\n\nso the return-side plug temperature becomes T - Delta T.\n\nTo avoid unphysical results (like cooling the plug to lower temperature than is inside the building), the implementation clamps return temperature to a configured minimal value (MINIMAL_RETURN_TEMPERATURE = 25.0).\n\n","category":"section"},{"location":"Plug_method/#Backward-pass-(return):-advection-and-merging","page":"Plug method","title":"Backward pass (return): advection and merging","text":"The backward pass pushes the cooled plugs from loads back to the producer using the return queues plugs_b.","category":"section"},{"location":"Plug_method/#Leaf-injection","page":"Plug method","title":"Leaf injection","text":"At each load (leaf), the cooled plug is pushed into the parent edge’s return queue.","category":"section"},{"location":"Plug_method/#Junction-merging","page":"Plug method","title":"Junction merging","text":"At an internal node, return plugs are collected from each child return edge (again using collect_exiting_water_plugs!). These multiple plug sequences must be merged into a single sequence going into the parent.\n\nThe code uses merge_water_plug_vectors!, which mixes the plugs according to the individual flows in merging pipes.\n\nAt the producer root, the merged plug sequence is combined to a single plug representing the return temperature entering the producer for that step.\n\n","category":"section"},{"location":"Plug_method/#Heat-loss-to-ambient-(dissipation-to-atmosphere)","page":"Plug method","title":"Heat loss to ambient (dissipation to atmosphere)","text":"After advection, both in forward and backward pass, the remaining plugs in pipes are cooled to account for heat loss to the environment.\n\nFor each plug, temperature is updated using an exponential model:\n\nT_next = T_a + (T - T_a)expleft(-fracDelta trho c_p A Rright)\n\nwhere:\n\nrho is water density (WATER_DENSITY)\nc_p is specific heat (WATER_SPECIFIC_HEAT)\nA is cross-sectional area of the pipe A = pi(fracd2)^2\nR is pipe thermal resistance ... this is given by pipe insulation and usually differs for forward and backward pass\n\n","category":"section"},{"location":"Plug_method/#Practical-notes-and-limitations","page":"Plug method","title":"Practical notes and limitations","text":"The current network traversal assumes a directed tree (each non-root node has one parent).\nThere is no axial mixing inside a pipe: plugs only merge when explicitly combined (e.g., at reporting points or junction return merging).\nThe plug representation is simplified over time by merging consecutive plugs with nearly identical temperature (merge_same_temperature_plugs!).\nStability and realism depend on choosing a reasonable Δt relative to flows and pipe volumes.","category":"section"},{"location":"#Distributed-Heating-Network-Simulator","page":"Distributed Heating Network Simulator","title":"Distributed Heating Network Simulator","text":"This is the Documentation for DHNetworkSimulator.\n\nDHNetworkSimulator is a Julia package for building, visualizing, and simulating district heating networks. Network is represented as directed tree graph, root node is producer and leaf are consumers (loads).\n\nThermodynamics is solved using quazi-dynamic assumption, which makes the problem tractable. The assumption is that hydraulics (change in flow, pressures) has frequency much higher than thermics (change in temperature). In simple words, pressure moves in water with speed of sound and temperature moves mainly with advection (the hot water itself moves).\n\nWe solve the dynamics in two steps:\n\nfind steady state of hydraulics\nsolve thermics by moving \"plugs\" of water. Consecutive plugs dont mix.\n\nMore on plug method in Plug method.\n\nsmall change","category":"section"},{"location":"#Getting-started","page":"Distributed Heating Network Simulator","title":"Getting started","text":"To install the package, open the Julia REPL and type\n\njulia> using Pkg; Pkg.add(\"https://github.com/PajaS22/DHNetworkSimulator\")","category":"section"},{"location":"#Examples","page":"Distributed Heating Network Simulator","title":"Examples","text":"The easiest way to get a feel for the API is to run one of the example scripts.\n\nscripts/basic_network.jl\nscripts/bigger_network.jl","category":"section"},{"location":"#Minimal-example-(policy-driven-simulation)","page":"Distributed Heating Network Simulator","title":"Minimal example (policy-driven simulation)","text":"run_simulation takes a network, a time vector, and a policy(t, Tₐ, T_back) callback that returns a ProducerOutput. Simulation than returns SimulationResults struct holding  time series of many physical variables of the network.\n\nusing DHNetworkSimulator\n\nnetwork = Network()\nnetwork[\"producer\"] = ProducerNode((0.0, 0.0))\n\n# ... add junctions/loads/pipes here ...\n\nt = collect(0.0:60.0:3*3600.0) # seconds\n\nfunction policy(t, Tₐ, T_back) # constant flow and temperature\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n# set initial temperatures in pipes to 75°C and 60°C\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\n# plot temperature of water entering loads\nplot_simulation_results(results, :T_load_in)","category":"section"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Network","page":"Types","title":"Network","text":"","category":"section"},{"location":"types/#Nodes","page":"Types","title":"Nodes","text":"","category":"section"},{"location":"types/#Edges","page":"Types","title":"Edges","text":"","category":"section"},{"location":"types/#DHNetworkSimulator.Network","page":"Types","title":"DHNetworkSimulator.Network","text":"The main data structure representing a district heating network, which consists of a MetaGraph containing nodes and edges with associated data, as well as labels for the producer and consumer nodes.\n\nmutable struct Network{T<:Integer} <: AbstractGraph{T}\n    mg::MetaGraph                               # MetaGraph from MetaGraphs.jl, it contains the network \n                                                  structure and node and edge data\n    producer_label::Union{Nothing, String}      # Label of the producer node\n    load_labels::Set{String}                    # Labels of the consumer nodes\n    neighbor_dicts::NeighborDicts               # Mappings to inneghbors and outneighbors for efficient access during simulation\nend\n\n# Constructors\n- `Network()`: Creates an empty DH network with no nodes or edges.\n- `Network(g::DiGraph)`: Creates a DH network from an existing directed graph structure.\n                         Nodes and edges are initialized with EmptyNode and EmptyEdge data.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.NodeType","page":"Types","title":"DHNetworkSimulator.NodeType","text":"Abstract type for all node types in the DH network (e.g., junctions, loads, producers).\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.NodeCommon","page":"Types","title":"DHNetworkSimulator.NodeCommon","text":"Common data for all node types in the DH network (e.g., junctions, loads, producers)\n\nmutable struct NodeCommon\n    info::String\n    position::Union{Missing, Tuple{Float64, Float64}}   # (x, y) coordinates\n    mass_flow::Union{Missing, Float64}                  # [kg/s]\nend\n\n# Constructors\n- `NodeCommon(info::String)`\n- `NodeCommon(info::String, position::Tuple{Float64, Float64})`\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.JunctionNode","page":"Types","title":"DHNetworkSimulator.JunctionNode","text":"DH network node representing a junction, where pipes can connect but no heat is produced or consumed.\n\nstruct JunctionNode <: NodeType\n    common::NodeCommon\nend\n\n# Constructors\n- `JunctionNode(info::String)`\n- `JunctionNode(info::String, position::Tuple{Float64, Float64})`\n- `JunctionNode(position::Tuple{Float64, Float64})`\n- `JunctionNode()`\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.LoadNode","page":"Types","title":"DHNetworkSimulator.LoadNode","text":"DH network node representing a load, which consumes heat.\n\nThe load field defines quadratic function of power consumption P(Tₐ) = p₀ + p₁Tₐ + p₂Tₐ².\n\nmutable struct LoadNode <: NodeType\n    common::NodeCommon\n    load::Union{Missing, NTuple{3, Float64}}     # Heat load function in kW, P(Tₐ) = p₀ + p₁*Tₐ + p₂*Tₐ²\n    m_rel::Union{Missing, Float64}               # Relative mass flow coefficient (for branching nodes)\nend\n\n# Constructors\n- `LoadNode(info::String; load=DEFAULT_LOAD)`: Creates a LoadNode with the specified info string and an optional load function (default is a typical load curve).\n- `LoadNode(info::String, position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)`\n- `LoadNode(info::String, position::Tuple{Float64, Float64}, load::NTuple{3, Float64})`\n- `LoadNode(info::String, position::Tuple{Float64, Float64}, m_rel::Float64; load=DEFAULT_LOAD)`\n- `LoadNode(position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)`\n- `LoadNode(; load=DEFAULT_LOAD)`\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.ProducerNode","page":"Types","title":"DHNetworkSimulator.ProducerNode","text":"DH network node representing a producer, which heats water.\n\nThere may be only one producer in the network, and it is identified by its label (producer_label field in Network).\n\nstruct ProducerNode <: NodeType\n    common::NodeCommon\nend\n\n# Constructors\n- `ProducerNode(info::String)`\n- `ProducerNode(info::String, position::Tuple{Float64, Float64})`\n- `ProducerNode(position::Tuple{Float64, Float64})`\n- `ProducerNode()`\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyNode","page":"Types","title":"DHNetworkSimulator.EmptyNode","text":"An empty node type used for initialization and placeholder purposes in the DH network.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EdgeType","page":"Types","title":"DHNetworkSimulator.EdgeType","text":"Abstract type for all edge types in the DH network (only one pipe for now).\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.EmptyEdge","page":"Types","title":"DHNetworkSimulator.EmptyEdge","text":"Empty edge type used for initialization and placeholder purposes in the DH network.\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.Plug","page":"Types","title":"DHNetworkSimulator.Plug","text":"Single plug of water in the pipe, characterized by its temperature and mass.\n\nmutable struct Plug\n    T::Float64  # Temperature at the plug [°C]\n    m::Float64  # mass of the plug [kg]\nend\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.InsulatedPipe","page":"Types","title":"DHNetworkSimulator.InsulatedPipe","text":"DH network edge representing an insulated pipe, which transports water between nodes.\n\nmutable struct InsulatedPipe <: EdgeType\n    info::String\n    physical_params::PipeParams\n    mass_flow::Union{Missing, Float64}  # Mass flow in [kg/s]\n    m_rel::Union{Missing, Float64}      # Relative mass flow coefficient (for branching pipes)\n    plugs_f::Vector{Plug}               # Queue of plugs in the pipe (forward direction)\n    plugs_b::Vector{Plug}               # Queue of plugs in the pipe (backward direction)\nend\n\n# Constructors\n- `InsulatedPipe(info::String; length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)`\n- `InsulatedPipe(info::String, params::PipeParams)`\n- `InsulatedPipe(params::PipeParams)`\n- `InsulatedPipe(length::Real)`\n\n\n\n\n\n","category":"type"},{"location":"types/#DHNetworkSimulator.PipeParams","page":"Types","title":"DHNetworkSimulator.PipeParams","text":"Physical parameters of a pipe, which are constant during the simulation.\n\nstruct PipeParams                       # unchanging physical parameters of the pipe\n    length::Float64                     # Length of the pipe [m]\n    inner_diameter::Float64             # Inner diameter [m]\n    heat_resistance_forward::Float64    # Thermal resistance [m*K/W]\n    heat_resistance_backward::Float64   # Thermal resistance [m*K/W]\nend\n\n# Constructors\n- `PipeParams(length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)`\n- `PipeParams(length::Float64, inner_diameter::Float64)`: uses default heat resistance values based on typical insulation properties.\n\n\n\n\n\n","category":"type"}]
}
