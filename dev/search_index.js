var documenterSearchIndex = {"docs":
[{"location":"types/#Network-nodes-and-edges","page":"Nodes and Edges","title":"Network nodes and edges","text":"This page documents the core data types used to represent a district heating network.\n\nThe package models a network as a directed graph where:\n\nvertices are nodes (ProducerNode, JunctionNode, LoadNode), and\nedges are pipes (InsulatedPipe) carrying water plugs.","category":"section"},{"location":"types/#Conventions","page":"Nodes and Edges","title":"Conventions","text":"Temperatures are in °C.\nMass flow is in kg/s.\nPipe lengths are in m, inner diameters in m.\nPower demand curves in LoadNode use coefficients in kW.\n\nnote: `missing` means not initialized\nMany fields use missing to represent “not set” or “not computed yet”. For example, mass_flow is typically filled during the steady-state hydraulics step.","category":"section"},{"location":"types/#Nodes","page":"Nodes and Edges","title":"Nodes","text":"See the API reference for: NodeType, NodeCommon, JunctionNode, LoadNode, ProducerNode, EmptyNode.","category":"section"},{"location":"types/#Edges","page":"Nodes and Edges","title":"Edges","text":"See the API reference for: EdgeType, EmptyEdge, Plug, InsulatedPipe, PipeParams.","category":"section"},{"location":"simulation/#Simulation","page":"Simulation","title":"Simulation","text":"This page describes how to run simulations with DHNetworkSimulator and how to interpret the results.\n\nThe simulation follows a quasi-dynamic approach:\n\nHydraulics are treated as steady state at each time step (mass flow distribution updates “instantly”).\nThermal dynamics are simulated by advecting discrete plugs of water through pipes.\n\nFor details of the plug model, see Plug method.","category":"section"},{"location":"simulation/#Run-simulation:-run_simulation","page":"Simulation","title":"Run simulation: run_simulation","text":"The main function is run_simulation(network, sim_time, policy; ...).\n\nAt a high level, for each step it:\n\ncalls policy(t, Tₐ, T_back) to get producer setpoints (ProducerOutput),\ncomputes steady-state mass flows (steady_state_hydronynamics!),\npropagates plugs forward (supply), applies load consumption, then propagates plugs backward (return),\nrecords temperatures / flows / powers into a SimulationResults.\n\nnote: Network is validated automatically\nrun_simulation calls check_network! before the first step. You do not need to call it manually as long as you constructed a valid directed tree with one producer and load leaves.\n\nAPI docs: run_simulation, ProducerOutput, SimulationResults, plot_simulation_results.\n\nExample of constant policy:\n\nfunction policy(t, Tₐ, T_back)\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\nExample of variable policy\n\nfunction policy(t, Tₐ, T_back)\n    T = 90 + 10*sin(2π*t/(24*3600)) # period of 24 hours\n\treturn ProducerOutput(mass_flow=15.0, temperature=T)\nend","category":"section"},{"location":"simulation/#Producer-setpoint","page":"Simulation","title":"Producer setpoint","text":"See ProducerOutput.","category":"section"},{"location":"simulation/#Simulation-logs:","page":"Simulation","title":"Simulation logs:","text":"Simulation logs data in struct SimulationResults. See SimulationResults.","category":"section"},{"location":"simulation/#Visualization-of-SimulationResults","page":"Simulation","title":"Visualization of SimulationResults","text":"SimulationResults can be easily displayed using function plot_simulation_results. See plot_simulation_results.","category":"section"},{"location":"simulation/#Minimal-workflow-(end-to-end)","page":"Simulation","title":"Minimal workflow (end-to-end)","text":"The typical workflow is:\n\nbuild a Network (see Network),\nattach node/edge parameters,\ndefine sim_time and policy, (optionally get also measurements of temperature)\ncall run_simulation,\nvisualize time series via plot_simulation_results.","category":"section"},{"location":"simulation/#simulation_examples","page":"Simulation","title":"Examples","text":"","category":"section"},{"location":"simulation/#Example-1:-sinusoidal-temperature","page":"Simulation","title":"Example 1: sinusoidal temperature","text":"using DHNetworkSimulator\n\n# network = ... build/parameterize a valid Network ...\n\nt = float.(collect(range(0, stop=3*60*60, step=60))) # simulate for three hours with 1 min time step\n# sinusoidal mass flow and temperature\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 15.0\n    temp = 90 + 10*sin(2π*t/(100*60)) # period of 100 minutes, oscillation between 80 and 100 °C\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\nplot_simulation_results(results, :T_load_in; title=\"Load Inlet Temperatures\")\n\n(Image: example 1 result)\n\nExample 1: sinusoidal temperature on input","category":"section"},{"location":"simulation/#Example-2:-varying-outdoor-temperature","page":"Simulation","title":"Example 2: varying outdoor temperature","text":"In real world there is time varying outdoor temperature, which has impact on the dissipation of energy during transport (if we have good isolation, not so much). Also, consumers consume more energy, when it's cold outside.\n\nWe have a measurement of real outdoor temperature in May 2024, lets try use it!\n\nAlso, our power plans surely has some limits, let's specify the power output to be 4 MW.\n\ntime_interval = [DateTime(2024, 5, 1), DateTime(2024, 5, 21)]\nTₐ = TSFrames.subset(outdoor_temperature_ts, time_interval...) # select only relevant interval\nTₐ_vec = Tₐ[:, :T_a_avg] # convert TSFrame to vector of outdoor temperatures for each time step\n\nt =  index(Tₐ) # get time vector in DateTime format\n\nproducer_power = 4_000_000.0 # 4 MW\nc_water = 4186.0 # J/(kg*K)\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 80.0 # constant mass flow of 80 kg/s\n    # P = (T2-T1) * mass_flow * water_specific_heat\n    temp = producer_power / (mass_flow * c_water) + T_back\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)\nplot_simulation_results(results, :T_load_out; title=\"Return temperatures on load side\")\n\n(Image: example 2 result)\n\nExample 2: varying outdoor temperature","category":"section"},{"location":"simulation/#Example-3:-control-the-output-temperature-with-constrained-power","page":"Simulation","title":"Example 3: control the output temperature with constrained power","text":"It's easy to say \"let's just produce water of 90°C\". To do that, we have to heat up the water and for that to happen, we must give the water considerable amount of energy. In real world, producers have some upper limits of energy they can deliver per second.\n\nLet's model that!\n\n# ... t, Tₐ_vec same as in previous example... #\n\nT_target = 90               # our target temperature\nPwr_max =  5_000_000.0      # maximal power output 5 MW\nfunction policy(t, Tₐ, T_back)\n    mass_flow = 80.0\n    P_target = (T_target - T_back) * mass_flow * c_water # power needed to reach T_target\n    P = min(P_target, Pwr_max)\n    temp = P / (mass_flow * c_water) + T_back\n    return ProducerOutput(mass_flow=mass_flow, temperature=temp)\nend\n\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)\nplot_simulation_results(results, :T_producer_out; title=\"Producer output temperature\", linestyle=:solid)\nplot_simulation_results(results, :power_load)\n\n(Image: example 3 producer output)\n\nExample 3: Producer is able to control temperature to 90°C most of the time.\n\n(Image: example 3 producer output)\n\nExample 3: Power consumption of loads depend on temperature, we see, that in some intervals, it sums up so much, that the total power consumption is higher that power production and water gets colder.","category":"section"},{"location":"Plug_method/#Plug-method","page":"Plug Method","title":"Plug method","text":"One of the ways to solve thermo-dynamics with hydraulics.\n\nThis project solves heat transport in a district heating network using a plug-flow (parcel) method. Each pipe contains a queue of discrete plugs of water, where every plug has:\n\ntemperature T [°C]\nmass m [kg]\n\nPlugs advect through pipes according to the current mass flows, exchange heat with the environment via a simple heat-loss model, and (optionally) lose heat at loads according to the load power demand.\n\nIn this example image we can see, that with variable flow and temperature, in each period there may be multiple different sized plugs of different temperatures exiting a pipe. (Image: plug_flow_example) Figure: Explanation of plug method [doc. Ing. Zdeněk Hurák, Ph.D., CTU]","category":"section"},{"location":"Plug_method/#Quasi-dynamic-assumption","page":"Plug Method","title":"Quasi-dynamic assumption","text":"The approach of solving our thermodynamic problem of flow is based on a quasi-dynamic assumption:\n\nHydraulics (mass flow distribution) is assumed to reach steady state “instantaneously” compared to\nThermal dynamics, which are dominated by advection (transport of hot water) and slow heat losses.\n\nAs a result, each simulation time step does:\n\ncompute steady-state mass flows (steady_state_hydronynamics!)\ntransport heat by moving plugs\nforward (supply) direction: from producer to loads\nheat extraction at loads: using a power-demand model (often based on outdoor-temperature compensation, sometimes called equithermal regulation)\nbackward (return) direction: from loads back to the producer","category":"section"},{"location":"Plug_method/#State-representation","page":"Plug Method","title":"State representation","text":"Each pipe edge represents two pipes and therefore stores two independent plug queues:\n\nplugs_f: plugs moving in the forward/supply direction\nplugs_b: plugs moving in the backward/return direction\n\nWithin a pipe, plugs are treated as non-mixing parcels (no axial mixing). Mixing is handled explicitly only where the network topology merges/splits flow.","category":"section"},{"location":"Plug_method/#One-simulation-time-step-(high-level)","page":"Plug Method","title":"One simulation time step (high level)","text":"For each time step of length Δt:\n\nInsert new hot plugs at the producer into each outgoing supply pipe.\nForward pass (supply): move plugs from producer to loads using current mass flows.\nLoads: compute required power P(T_a) from ambient temperature and cool the arriving plug accordingly.\nBackward pass (return): push cooled plugs back to the producer, mixing at junctions as needed.\nHeat losses to ambient: cool all plugs remaining in pipes (supply and return) using an exponential heat-loss model.\n\nThe overall simulation loop is orchestrated by run_simulation.\n\n","category":"section"},{"location":"Plug_method/#Forward-pass-(supply):-advection-and-splitting","page":"Plug Method","title":"Forward pass (supply): advection and splitting","text":"","category":"section"},{"location":"Plug_method/#1)-Plug-injection-at-the-source","page":"Plug Method","title":"1) Plug injection at the source","text":"For each outgoing edge from the producer, a new plug is created with:\n\nm_in = dot mDelta t\n\nand temperature equal to the producer outlet temperature for that step. The plug is appended to that pipe’s forward queue.","category":"section"},{"location":"Plug_method/#2)-Plug-advection-through-a-pipe","page":"Plug Method","title":"2) Plug advection through a pipe","text":"For a pipe with mass flow dot m, the algorithm computes the mass that must exit the pipe in this step:\n\nm_out = dot mDelta t\n\nIt then pops plugs from the front of the queue until the exiting mass is reached. If a plug is larger than the remaining mass to exit, it is split into an exiting part and a remaining part.\n\nThis is implemented by collect_exiting_water_plugs!.","category":"section"},{"location":"Plug_method/#3)-Junction-splitting-(tree)","page":"Plug Method","title":"3) Junction splitting (tree)","text":"When a node has multiple children, the exiting plug mass is split among outgoing edges proportional to edge mass flows:\n\nm_child = m_plugfracdot m_childsum_k dot m_k\n\nEach child receives a new plug with the same temperature and the computed mass. These plugs are appended to the child edges’ forward queues.","category":"section"},{"location":"Plug_method/#4)-Leaf-handling-(load-inlet-plug)","page":"Plug Method","title":"4) Leaf handling (load inlet plug)","text":"At a leaf node, all plugs that arrive during the step are combined into a single representative plug using a mass-weighted average:\n\nT_avg = fracsum_i T_i m_isum_i m_i\n\nThis is implemented by combine_plugs.\n\nThe resulting plug is interpreted as the supply plug entering the load for this time step.\n\n","category":"section"},{"location":"Plug_method/#Load-model:-consuming-heat","page":"Plug Method","title":"Load model: consuming heat","text":"Each load node computes power demand based on ambient temperature T_a (we use a 2nd-order polynomial approximation):\n\nP = P(T_a) = p_1 + p_2 T_a + p_3 T_a^2\n\nThe entering plug is cooled by energy extraction over the step:\n\nDelta T = fracPDelta tmc_p\n\nso the return-side plug temperature becomes T - Delta T.\n\nTo avoid unphysical results (like cooling the plug to lower temperature than is inside the building), the implementation clamps return temperature to a configured minimal value (MINIMAL_RETURN_TEMPERATURE = 25.0).\n\n","category":"section"},{"location":"Plug_method/#Backward-pass-(return):-advection-and-merging","page":"Plug Method","title":"Backward pass (return): advection and merging","text":"The backward pass pushes the cooled plugs from loads back to the producer using the return queues plugs_b.","category":"section"},{"location":"Plug_method/#Leaf-injection","page":"Plug Method","title":"Leaf injection","text":"At each load (leaf), the cooled plug is pushed into the parent edge’s return queue.","category":"section"},{"location":"Plug_method/#Junction-merging","page":"Plug Method","title":"Junction merging","text":"At an internal node, return plugs are collected from each child return edge (again using collect_exiting_water_plugs!). These multiple plug sequences must be merged into a single sequence going into the parent.\n\nThe code uses merge_water_plug_vectors!, which mixes the plugs according to the individual flows in merging pipes.\n\nAt the producer root, the merged plug sequence is combined to a single plug representing the return temperature entering the producer for that step.\n\n","category":"section"},{"location":"Plug_method/#Heat-loss-to-ambient-(dissipation-to-atmosphere)","page":"Plug Method","title":"Heat loss to ambient (dissipation to atmosphere)","text":"After advection, both in forward and backward pass, the remaining plugs in pipes are cooled to account for heat loss to the environment.\n\nFor each plug, temperature is updated using an exponential model:\n\nT_next = T_a + (T - T_a)expleft(-fracDelta trho c_p A Rright)\n\nwhere:\n\nrho is water density (WATER_DENSITY)\nc_p is specific heat (WATER_SPECIFIC_HEAT)\nA is cross-sectional area of the pipe A = pi(fracd2)^2\nR is pipe thermal resistance ... this is given by pipe insulation and usually differs for forward and backward pass\n\n","category":"section"},{"location":"Plug_method/#Practical-notes-and-limitations","page":"Plug Method","title":"Practical notes and limitations","text":"The current network traversal assumes a directed tree (each non-root node has one parent).\nThere is no axial mixing inside a pipe: plugs only merge when explicitly combined (e.g., at reporting points or junction return merging).\nThe plug representation is simplified over time by merging consecutive plugs with nearly identical temperature (merge_same_temperature_plugs!).\nStability and realism depend on choosing a reasonable Δt relative to flows and pipe volumes.","category":"section"},{"location":"search/#Search-/-Index","page":"Search","title":"Search / Index","text":"","category":"section"},{"location":"Network/#Network","page":"Network","title":"Network","text":"Network is the main model type in DHNetworkSimulator. It represents a district heating network as a directed graph:\n\nwater flows from one producer (the source/root),\nthrough optional junctions (branching/merging points),\nto multiple loads (consumers, typically leaves).\n\nUnlike a plain graph, a Network stores typed domain data on:\n\nnodes: ProducerNode, JunctionNode, LoadNode (plus EmptyNode as a placeholder during construction),\nedges: typically InsulatedPipe (plus EmptyEdge as a placeholder during construction).\nmore on nodes and edges in Network nodes and edges\n\nThis design makes it straightforward to build a topology, attach physical parameters, and run the hydraulic + thermal simulation.\n\nSee Network in the API reference.","category":"section"},{"location":"Network/#Features","page":"Network","title":"Features","text":"Typed nodes and edges: domain structs like ProducerNode, LoadNode, and InsulatedPipe are stored directly on the graph.\nLabel-based addressing: access nodes/edges by string labels (nw[\"A\"], nw[\"A\", \"B\"]).\nGraphs.jl compatibility: Network subtypes AbstractGraph, so you can use functions like nv, ne, vertices, and edges.\nValidated structural assumptions: run_simulation calls DHNetworkSimulator.check_network! to validate the topology (one producer, acyclic, connected, loads are leaves).\nFast neighbor access: cached neighbor lists via NeighborDicts with label-based helpers outneighbors / inneighbors.\nBuilt-in visualization: interactive plotting via visualize_graph! with edge labels from edge_info / edge_info_hover.","category":"section"},{"location":"Network/#Implementation-details","page":"Network","title":"Implementation details","text":"","category":"section"},{"location":"Network/#MetaGraph","page":"Network","title":"MetaGraph","text":"For the internal graph structure we use MetaGraph MetaGraphNext.jl, because it is type stable (not like MetaGraphs.jl). We prefer it over Graphs.jl for 2 main reasons:\n\ngraph from Graphs.jl has not stable indexing: when a node is removed, all the nodes are reindexed so that there are no gaps in indexing. For example we have graph with three vertices {V[1], V[2], V[3]}. If we remove the middle vertex V[2], the vertex V[3]'s indexing is changed to be V[2]. On the other hand, if we remove vertex V[B] from metagraph {V[A], V[B], V[C]}, the indexing (or rather labeling) stays the same and we get {V[A], V[C]}\nMetaGraph lets us store node/edge data on the vertices/edges.","category":"section"},{"location":"Network/#Indexing-by-Labels","page":"Network","title":"Indexing by Labels","text":"Nodes and edges are addressed by string labels:\n\nnw[\"A\"] returns the node data for label \"A\".\nnw[\"A\", \"B\"] returns the edge data from \"A\" to \"B\".\n\nBecause Network subtypes AbstractGraph, you can also use Graphs.jl-style APIs such as nv, ne, vertices, and edges.\n\nwarning: Graphs.jl indices vs MetaGraphNext labels\nFunctions like vertices, edges, src(e), dst(e) from Graphs.jl give you vertex indices from the underlying graph. To convert an index back to a label, use label_for(nw, idx).","category":"section"},{"location":"Network/#Structural-Assumptions-(Validated-at-Simulation-Start)","page":"Network","title":"Structural Assumptions (Validated at Simulation Start)","text":"The simulator assumes the network is static during a run (topology does not change while stepping). Before simulation starts, DHNetworkSimulator validates that:\n\nthere is exactly one producer node (producer_label must be set),\nthe directed graph is acyclic,\nthe graph is connected (all nodes are reachable from the producer),\nload nodes are leaves (outdegree 0).\n\nrun_simulation calls check_network! internally before the first step, which does all of that, no need to do it yourself.","category":"section"},{"location":"Network/#Neighbor-Caching-(NeighborDicts)","page":"Network","title":"Neighbor Caching (NeighborDicts)","text":"Thermal and hydraulic stepping frequently calls outneighbors(nw, label) and inneighbors(nw, label). To reduce allocations and repeated work, Network maintains cached neighbor lists in NeighborDicts:\n\nSee NeighborDicts in the API reference.\n\nWhen you modify the network structure (add/remove/rename nodes or edges), the cache is marked dirty. It is rebuilt automatically when needed (for example in run_simulation via check_network!). Also simple call outneighbors(network,label) makes the cache update if marked dirty.","category":"section"},{"location":"Network/#Typical-Workflows","page":"Network","title":"Typical Workflows","text":"","category":"section"},{"location":"Network/#1)-Create-a-Network-From-a-Graph-Topology","page":"Network","title":"1) Create a Network From a Graph Topology","text":"Use this when the topology already exists (e.g., imported from data or generated programmatically) and you want to attach node/edge data afterward.\n\nusing DHNetworkSimulator\nusing Graphs\n\n# 1 -> 2 -> 3, and 2 -> 4\ng = DiGraph(4)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 2, 4)\n\nnw = Network(g)\nname_nodes!(nw, [\"P\", \"J\", \"L1\", \"L2\"]) # rename 1..n to meaningful labels\nidentify_producer_and_loads!(nw)            # assign Producer/Junction/Load node types\n\n# attach pipe parameters (edge data)\nnw[\"P\", \"J\"]  = InsulatedPipe(\"P→J\";  length=300.0, inner_diameter=0.10)\nnw[\"J\", \"L1\"] = InsulatedPipe(\"J→L1\"; length=150.0, inner_diameter=0.08)\nnw[\"J\", \"L2\"] = InsulatedPipe(\"J→L2\"; length=180.0, inner_diameter=0.08)\n\nne(nw), nv(nw)\n\nWe can also display all sorts of info about the network:\n\njulia> nw\nDH Network:\n Number of nodes: 4\n Number of edges: 3\n Producer node: P\n Load nodes (2): {L1, L2}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] L1 : Load Node, Info: L1, Load (at 0°C): 540.0 kW\n[2] P : Producer Node, Info: P\n[3] J : Junction Node, Info: J\n[4] L2 : Load Node, Info: L2, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[2] P -->  [3] J : Pipe Edge, L=300.0, D_in=0.1, R_f=3.0, R_b=4.0\n[3] J -->  [1] L1 : Pipe Edge, L=150.0, D_in=0.08, R_f=3.0, R_b=4.0\n[3] J -->  [4] L2 : Pipe Edge, L=180.0, D_in=0.08, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#2)-Build-a-Small-Network-Manually","page":"Network","title":"2) Build a Small Network Manually","text":"For quick experiments you can start from Network() and assign nodes/edges directly by label.\n\nusing DHNetworkSimulator\n\nnw = Network()\nnw[\"P\"]  = ProducerNode(\"Plant\", (0.0, 0.0))\nnw[\"L1\"] = LoadNode(\"House 1\", (1.0, 0.0))\n\nnw[\"P\", \"L1\"] = InsulatedPipe(\"P→L1\"; length=200.0, inner_diameter=0.10)\n\njulia> nw\nDH Network:\n Number of nodes: 2\n Number of edges: 1\n Producer node: P\n Load nodes (1): {L1}\n Neighbor dicts need rebuild: true\n---\nNodes in the network:\n[1] P : Producer Node, Info: Plant\n[2] L1 : Load Node, Info: House 1, Load (at 0°C): 540.0 kW\n---\nEdges in the network:\n[1] P -->  [2] L1 : Pipe Edge, L=200.0, D_in=0.1, R_f=3.0, R_b=4.0","category":"section"},{"location":"Network/#Network-visualization","page":"Network","title":"Network visualization","text":"Visualization (plotting) of network is another feature that will come in handy. We can pan, zoom and if we hover over an edge, it turns red and additional info is shown.\n\nBy calling visualize_graph!(network) we get Makies display of our network.\n\nBlue nodes are loads, green is producer, black lines are pipes. The thicker the line, the bigger the pipe.\n\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz1) Vizualization of example network\n\nIf there is computed steady state flow first, the visualization shows the flow in the edges as well. The darker the more flow there is, which makes easy to analyze turbulance. Also, additional info is written in labels next to the edges and the exact flow velocity in [m/s] is shown upon hover.\n\nsteady_state_hydronynamics!(network, 100.0)\nf, ax, p = visualize_graph!(network)\ndisplay(f)\n\n(Image: network_viz2) Zoomed in part of a network after computing steady state of hydrodynamics","category":"section"},{"location":"Network/#When-to-Use-Network","page":"Network","title":"When to Use Network","text":"Network is intended for modeling and simulation tasks such as:\n\nControl and policy studies: define a policy(t, Tₐ, T_back) callback and see how actions affect supply/return temperatures.\nDesign what-ifs: change pipe parameters and compare temperature drops, delays, and load satisfaction.\nTopology experiments: evaluate different branching structures and relative flow splits.\nVisualization & debugging: inspect the graph, pipe information, and computed flows.","category":"section"},{"location":"#Distributed-Heating-Network-Simulator","page":"Home","title":"Distributed Heating Network Simulator","text":"This is the documentation for DHNetworkSimulator (source code on github).\n\nDHNetworkSimulator is a Julia package for building, visualizing, and simulating district heating networks. A network is modeled as a directed, acyclic tree: a single producer sits at the root, water flows through junctions, and consumers (loads) are typically leaves.\n\nThe simulator uses a quasi-dynamic formulation to keep the problem tractable. At each time step, hydraulics (mass-flow distribution and pressures) are assumed to reach steady state much faster than temperature changes. Thermal dynamics are then dominated by advection (hot water moving through pipes) and heat losses to the ambient.\n\nEach time step is therefore solved in two stages:\n\ncompute steady-state hydraulics,\nadvance temperatures with a plug-flow model that transports discrete “plugs” (parcels) of water through pipes. Plugs do not mix inside a pipe; mixing happens at junctions when flows merge and converge.\n\nSimulations are typically policy-driven: you provide a policy(t, Tₐ, T_back) callback that returns the producer setpoints, and the simulator logs time series of temperatures, flows, and powers.\n\nMore details on the thermal model are in Plug method.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install the package, open the Julia REPL and type\n\njulia> using Pkg; Pkg.add(url=\"https://github.com/PajaS22/DHNetworkSimulator\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"The easiest way to get a feel for the API is to run one of the example scripts. You can find them after cloning the repo in subfolder scripts.\n\nscripts/basic_network.jl\nscripts/bigger_network.jl","category":"section"},{"location":"#Minimal-example-(policy-driven-simulation)","page":"Home","title":"Minimal example (policy-driven simulation)","text":"run_simulation takes a network, a time vector, and a policy(t, Tₐ, T_back) callback that returns a ProducerOutput. Simulation than returns SimulationResults struct holding  time series of many physical variables of the network.\n\nusing DHNetworkSimulator\n\nnetwork = Network()\nnetwork[\"producer\"] = ProducerNode((0.0, 0.0))\n\n# ... add junctions/loads/pipes here ...\n\nt = collect(0.0:60.0:3*3600.0) # seconds\n\nfunction policy(t, Tₐ, T_back) # constant flow and temperature\n\treturn ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n# set initial temperatures in pipes to 75°C and 60°C\nresults = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)\n# plot temperature of water entering loads\nplot_simulation_results(results, :T_load_in)\n\nMore examples can be found in Simulation examples.","category":"section"},{"location":"API/#API-reference","page":"API","title":"API reference","text":"This page collects the public API of DHNetworkSimulator in one place.","category":"section"},{"location":"API/#Core-types","page":"API","title":"Core types","text":"","category":"section"},{"location":"API/#Network-and-topology","page":"API","title":"Network and topology","text":"","category":"section"},{"location":"API/#Nodes-and-edges","page":"API","title":"Nodes and edges","text":"","category":"section"},{"location":"API/#Simulation-I/O","page":"API","title":"Simulation I/O","text":"","category":"section"},{"location":"API/#Network-construction-and-manipulation","page":"API","title":"Network construction and manipulation","text":"","category":"section"},{"location":"API/#Graph-interface","page":"API","title":"Graph interface","text":"Network implements parts of the Graphs.jl interface (e.g., nv, ne, vertices, edges, outdegree, indegree, neighbors).\n\nThese label-based helpers are provided by DHNetworkSimulator:","category":"section"},{"location":"API/#Visualization-and-printing","page":"API","title":"Visualization and printing","text":"","category":"section"},{"location":"API/#Pipe-geometry-and-hydraulics-helpers","page":"API","title":"Pipe geometry and hydraulics helpers","text":"","category":"section"},{"location":"API/#Plug-method-helpers","page":"API","title":"Plug-method helpers","text":"","category":"section"},{"location":"API/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"API/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"API/#External-helpers","page":"API","title":"External helpers","text":"This package relies on MetaGraphsNext.jl internally. If you need to convert a Graphs.jl vertex index back to the stored string label, use MetaGraphsNext.label_for(nw.mg, idx).","category":"section"},{"location":"API/#DHNetworkSimulator.Network","page":"API","title":"DHNetworkSimulator.Network","text":"Network type representing a district heating network.\n\nmutable struct Network{T<:Integer} <: AbstractGraph{T}\n    mg::MetaGraph                               # MetaGraph from MetaGraphs.jl, it contains the network \n                                                    structure and node and edge data\n    producer_label::Union{Nothing, String}      # Label of the producer node\n    load_labels::Set{String}                    # Labels of the consumer nodes\n    neighbor_dicts::NeighborDicts               # Mappings to inneghbors and outneighbors for efficient access during simulation\nend\n\nFields\n\nmg: a MetaGraphsNext MetaGraph that contains the directed topology and stores node/edge data.\nproducer_label: label of the single producer node (or nothing if not yet set).\nload_labels: a set of labels for load nodes.\nneighbor_dicts: cached neighbor lists used to reduce allocations during simulation.\n\nConstructors\n\nNetwork(): Creates an empty DH network with no nodes or edges.\nNetwork(g::DiGraph): Creates a DH network from an existing directed graph structure ('Graphs.jl').                        Nodes and edges are initialized with EmptyNode and EmptyEdge data.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.NeighborDicts","page":"API","title":"DHNetworkSimulator.NeighborDicts","text":"Mappings to inneghbors and outneighbors for efficient access during simulation, stored in the Network struct.\n\nWhen calling functions outneighbors(nw, label) or inneighbors(nw, label),  there is no need to scan through the graph and collect neighbors,  instead we can directly access the pre-computed neighbor lists in the dictionaries. This significantly lowers the number of allocations during simulation, because there is a lot of places where we need to access neighbors of a node.\n\nThe network is static during the simulation, so we can compute these neighbor lists once before the simulation starts and then reuse them.\n\nmutable struct NeighborDicts\n    outneighbors::Dict{String, Vector{String}}       # mapping nodes to outneighbors for efficient access in simulation\n    inneighbors::Dict{String, Vector{String}}        # mapping nodes to inneighbors for efficient access in simulation\n    need_rebuild::Bool                               # flag to indicate if neighbor dicts need to be rebuilt before simulation\nend\n\nneed_rebuild flag is used to indicate when the neighbor dicts need to be updated  (e.g., after adding/removing nodes or edges), so that we can avoid unnecessary   rebuilding during multiple modifications.\n\nConstructor\n\nNeighborDicts(): Creates an instance of NeighborDicts with empty dictionaries and the need_rebuild flag set to true.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.NodeType","page":"API","title":"DHNetworkSimulator.NodeType","text":"Abstract supertype for all node types in a district heating network.\n\nConcrete node types describe the role of a vertex in the directed network:\n\nProducerNode: heat source (root)\nJunctionNode: branching/merging point\nLoadNode: heat consumer (typically a leaf)\nEmptyNode: placeholder used during construction\n\nAll concrete node types store a common::NodeCommon field with metadata such as info, position, and (optionally) the current steady-state mass_flow.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.EdgeType","page":"API","title":"DHNetworkSimulator.EdgeType","text":"Abstract supertype for all edge types in a district heating network.\n\nEdges represent physical connections between nodes. In this package the primary edge type is InsulatedPipe. EmptyEdge is used as a placeholder (e.g., when building a network from a bare topology).\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.NodeCommon","page":"API","title":"DHNetworkSimulator.NodeCommon","text":"Common data for all node types in the DH network.\n\nNodeCommon contains fields that are useful across producers, junctions, and loads.\n\nmutable struct NodeCommon\n    info::String\n    position::Union{Missing, Tuple{Float64, Float64}}   # (x, y) coordinates\n    mass_flow::Union{Missing, Float64}                  # [kg/s]\nend\n\nFields\n\ninfo::String: human-readable label shown in printing/plots.\nposition::Union{Missing, Tuple{Float64, Float64}}: optional (x,y) coordinates (used by visualization).\nmass_flow::Union{Missing, Float64}: steady-state mass flow through the node in kg/s.\n\nNotes\n\nMany fields use missing to represent “not initialized / not computed yet”.\nDuring simulation, mass flows are usually filled by steady_state_hydronynamics!.\n\nConstructors\n\nNodeCommon(info::String)\nNodeCommon(info::String, position::Tuple{Float64, Float64})\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.ProducerNode","page":"API","title":"DHNetworkSimulator.ProducerNode","text":"DH network node representing a producer (heat source).\n\nThere may be only one producer in the network, and it is identified by its label (producer_label field in Network).\n\nIn simulations, the producer’s mass flow and supply temperature are usually provided by a control policy (see ProducerOutput and run_simulation).\n\nstruct ProducerNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nProducerNode(info::String)\nProducerNode(info::String, position::Tuple{Float64, Float64})\nProducerNode(position::Tuple{Float64, Float64})\nProducerNode()\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.JunctionNode","page":"API","title":"DHNetworkSimulator.JunctionNode","text":"DH network node representing a junction.\n\nJunctions are internal vertices that connect multiple pipes but do not directly produce or consume heat. They are where flow splits (supply direction) or merges (return direction).\n\nstruct JunctionNode <: NodeType\n    common::NodeCommon\nend\n\nConstructors\n\nJunctionNode(info::String)\nJunctionNode(info::String, position::Tuple{Float64, Float64})\nJunctionNode(position::Tuple{Float64, Float64})\nJunctionNode()\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.LoadNode","page":"API","title":"DHNetworkSimulator.LoadNode","text":"DH network node representing a load (consumer).\n\nThe load field defines a quadratic power-demand curve as a function of ambient temperature T_a:\n\nP(T_a) = p_0 + p_1 T_a + p_2 T_a^2 where the power is in kW and the ambient temperature is in °C.\n\nThe m_rel field is a relative mass-flow coefficient used when splitting flows at a junction while solving steady state flow; it is specified for leaf nodes and propagated to upstream edges.\n\nmutable struct LoadNode <: NodeType\n    common::NodeCommon\n    load::Union{Missing, NTuple{3, Float64}}     # Heat load function in kW, P(Tₐ) = p₀ + p₁*Tₐ + p₂*Tₐ²\n    m_rel::Union{Missing, Float64}               # Relative mass flow coefficient (for branching nodes)\nend\n\nConstructors\n\nLoadNode(info::String; load=DEFAULT_LOAD): Creates a LoadNode with the specified info string and an optional load function (default is a typical load curve).\nLoadNode(info::String, position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(info::String, position::Tuple{Float64, Float64}, load::NTuple{3, Float64})\nLoadNode(info::String, position::Tuple{Float64, Float64}, m_rel::Float64; load=DEFAULT_LOAD)\nLoadNode(position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)\nLoadNode(; load=DEFAULT_LOAD)\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.EmptyNode","page":"API","title":"DHNetworkSimulator.EmptyNode","text":"Placeholder node type.\n\nEmptyNode is used when constructing a Network from a bare topology (e.g. Network(graph::DiGraph)). Replace placeholders with real node types (ProducerNode, JunctionNode, LoadNode) before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.PipeParams","page":"API","title":"DHNetworkSimulator.PipeParams","text":"Physical parameters of a pipe (constant during simulation).\n\nThese parameters describe geometry and heat-loss characteristics.\n\nstruct PipeParams                       # unchanging physical parameters of the pipe\n    length::Float64                     # Length of the pipe [m]\n    inner_diameter::Float64             # Inner diameter [m]\n    heat_resistance_forward::Float64    # Thermal resistance [m*K/W]\n    heat_resistance_backward::Float64   # Thermal resistance [m*K/W]\nend\n\nFields\n\nlength [m]\ninner_diameter [m]\nheat_resistance_forward [m·K/W]: thermal resistance for the supply direction\nheat_resistance_backward [m·K/W]: thermal resistance for the return direction\n\nConstructors\n\nPipeParams(length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nPipeParams(length::Float64, inner_diameter::Float64): uses default heat resistance values based on typical insulation properties.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.InsulatedPipe","page":"API","title":"DHNetworkSimulator.InsulatedPipe","text":"DH network edge representing an insulated pipe.\n\nInsulatedPipe transports water between nodes and stores both physical parameters and the current hydraulic/thermal state.\n\nmutable struct InsulatedPipe <: EdgeType\n    info::String\n    physical_params::PipeParams\n    mass_flow::Union{Missing, Float64}  # Mass flow in [kg/s]\n    m_rel::Union{Missing, Float64}      # Relative mass flow coefficient (for branching pipes)\n    plugs_f::Vector{Plug}               # Queue of plugs in the pipe (forward direction)\n    plugs_b::Vector{Plug}               # Queue of plugs in the pipe (backward direction)\nend\n\nFields\n\n`physical_params: geometry and heat-loss parameters.\nmass_flow: mass flow in kg/s (typically computed bysteadystatehydronynamics!`).\n`m_rel: relative flow coefficient used for splitting at junctions.\n`plugs_f: plug queue for the forward (supply) direction.\n`plugs_b: plug queue for the backward (return) direction.\n\nConstructors\n\nInsulatedPipe(info::String; length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)\nInsulatedPipe(info::String, params::PipeParams)\nInsulatedPipe(params::PipeParams)\nInsulatedPipe(length::Real)\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.Plug","page":"API","title":"DHNetworkSimulator.Plug","text":"A single water plug used by the plug-method pipe model.\n\nA Plug represents a mass of water inside a pipe that is assumed to have uniform temperature. Plugs are advected through pipes during time stepping and may be split/merged.\n\nmutable struct Plug\n    T::Float64  # Temperature at the plug [°C]\n    m::Float64  # mass of the plug [kg]\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.EmptyEdge","page":"API","title":"DHNetworkSimulator.EmptyEdge","text":"Placeholder edge type.\n\nEmptyEdge is used when constructing a Network from a topology without pipe parameters. Replace it with InsulatedPipe before running simulations.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.ProducerOutput","page":"API","title":"DHNetworkSimulator.ProducerOutput","text":"Control input returned by a simulation policy.\n\nProducerOutput represents the producer setpoints for one time step.\n\nstruct ProducerOutput\n    mass_flow::Float64\n    temperature::Float64\nend\n\nFields\n\nmass_flow: total mass flow injected into the network in kg/s.\ntemperature: producer outlet (supply) temperature in °C.\n\nUsage\n\nThe policy passed to run_simulation must return a ProducerOutput:\n\nfunction policy(t, Tₐ, T_back)\n    return ProducerOutput(mass_flow=15.0, temperature=90.0)\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.SimulationResults","page":"API","title":"DHNetworkSimulator.SimulationResults","text":"Results of a simulation run.\n\nSimulationResults stores the time series produced by run_simulation.\n\nstruct SimulationResults\n        time::Union{Vector{Float64}, Vector{DateTime}}\n        mass_flow_load::Matrix{Float64}\n        mass_flow_producer::Vector{Float64}\n        T_load_in::Matrix{Float64}\n        T_load_out::Matrix{Float64}\n        T_producer_in::Vector{Float64}\n        T_producer_out::Vector{Float64}\n        power_load::Matrix{Float64}\n        power_producer::Vector{Float64}\n        load_labels::Dict{String, Int}\nend\n\nFields\n\ntime: simulation time vector.\nVector{Float64}: time in seconds.\nVector{DateTime}: absolute timestamps.\nmass_flow_load: load mass flows in kg/s. Size N × nloads.\nmass_flow_producer: producer mass flow in kg/s. Length N.\nT_load_in: temperature entering each load (supply side) in °C. Size N × nloads.\nT_load_out: temperature leaving each load (return side) in °C. Size N × nloads.\nT_producer_in: return temperature entering the producer in °C. Length N.\nT_producer_out: supply temperature leaving the producer in °C. Length N.\npower_load: load power consumption in kW. Size N × nloads.\npower_producer: producer power output in MW (computed from mass flow and ΔT). Length N-1.\nload_labels: mapping from load label to column index used in the *_load matrices.\n\nIndexing\n\nConvenience accessors are provided:\n\nsr[:time] returns the time vector.\nsr[:load_labels] returns the load labels.\nsr[:load_labels_dict] returns the label→column dictionary.\nsr[\"L1\", :T_load_in] returns the time series for that load L1 (a vector).\n\nNotes\n\nAll matrices are organized as (time step, load index).\npower_producer has length N-1 because the producer heats the water that entered in in previous! time step.\n\n\n\n\n\n","category":"type"},{"location":"API/#DHNetworkSimulator.fill_physical_params!","page":"API","title":"DHNetworkSimulator.fill_physical_params!","text":"Fill the physical parameters of the edges in the network based on the provided pipe_params dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.fill_node_positions!","page":"API","title":"DHNetworkSimulator.fill_node_positions!","text":"Fill the positions of the nodes in the network based on the provided node_positions dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.fill_load_specs!","page":"API","title":"DHNetworkSimulator.fill_load_specs!","text":"Fill the load specifications: (power coefficients and relative mass flow)\n\npwr_coefs specifies tuples of power coefficients (p0, p1, p2) for the quadratic power curve.\nm_r specifies relative mass flow coefficients\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.name_nodes!","page":"API","title":"DHNetworkSimulator.name_nodes!","text":"Rename the nodes in the network according to the provided labels vector.\n\nThe order of labels should correspond to the order in which were the nodes added to the graph (default labels are \"1\", \"2\", ..., \"n\").\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.identify_producer_and_loads!","page":"API","title":"DHNetworkSimulator.identify_producer_and_loads!","text":"Identify the producer and load nodes in the network.\n\nThis comes in handy in situation when the graph was provided without node types (e.g. from a file)  and we want to classify the nodes based on their connectivity.\n\nThis function classifies nodes based on their degree:\n\nNodes with outdegree > 0 and indegree == 0 are classified as ProducerNode (source).\nNodes with outdegree == 0 and indegree > 0 are classified as LoadNode (sink).\nNodes with outdegree > 0 and indegree > 0 are classified as JunctionNode.\nNodes with outdegree == 0 and indegree == 0 are classified as EmptyNode (isolated).   these should not appear in a valid network!\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.has_label","page":"API","title":"DHNetworkSimulator.has_label","text":"Return true if label exists as a node label in the network.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.index_for","page":"API","title":"DHNetworkSimulator.index_for","text":"Return the internal vertex index for a given node label.\n\nThis is mainly useful when interacting with Graphs.jl functions that operate on integer vertex indices.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.rem_node!","page":"API","title":"DHNetworkSimulator.rem_node!","text":"Remove a node from a Network by its string label.\n\nThis updates producer_label / load_labels as needed and marks neighbor caches dirty.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.rename_node!","page":"API","title":"DHNetworkSimulator.rename_node!","text":"Rename a node label in-place.\n\nThis preserves the node data and all incident edges by removing the old label and re-inserting under new_label.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.vertices_data","page":"API","title":"DHNetworkSimulator.vertices_data","text":"Return a vector of all node data stored in a Network (in label order).\n\n\n\n\n\nReturn a vector of all node data stored in a MetaGraphsNext MetaGraph (in label order).\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.edges_data","page":"API","title":"DHNetworkSimulator.edges_data","text":"Return a vector of all edge data stored in a Network.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.all_labels","page":"API","title":"DHNetworkSimulator.all_labels","text":"Return all vertex labels in the network.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.outneighbors","page":"API","title":"DHNetworkSimulator.outneighbors","text":"Return outgoing neighbor labels for a node label.\n\nThis is the Network-specific overload that returns string labels (not Graphs.jl vertex indices). Neighbor caches are rebuilt automatically when needed.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.inneighbors","page":"API","title":"DHNetworkSimulator.inneighbors","text":"Return incoming neighbor labels for a node label.\n\nThis is the Network-specific overload that returns string labels (not Graphs.jl vertex indices). Neighbor caches are rebuilt automatically when needed.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.visualize_graph!","page":"API","title":"DHNetworkSimulator.visualize_graph!","text":"Visualize a Network using GraphMakie.\n\nReturns (figure, axis, plot) from GraphMakie.graphplot. If edge mass flows have been computed (e.g. via steady_state_hydronynamics!), the plot also shows flow-dependent edge styling.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.edge_info","page":"API","title":"DHNetworkSimulator.edge_info","text":"Human-readable edge label used by default in visualize_graph!.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.edge_info_hover","page":"API","title":"DHNetworkSimulator.edge_info_hover","text":"Human-readable edge label used on hover in visualize_graph!.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.edge_infos","page":"API","title":"DHNetworkSimulator.edge_infos","text":"Vectorized helper returning labels for all edges in a MetaGraph.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.print_nodes","page":"API","title":"DHNetworkSimulator.print_nodes","text":"Print all nodes of the network with their stored node data.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.print_edges","page":"API","title":"DHNetworkSimulator.print_edges","text":"Print all edges of the network with their stored edge data.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.pipe_length","page":"API","title":"DHNetworkSimulator.pipe_length","text":"Return physical pipe length in meters.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.length-Tuple{InsulatedPipe}","page":"API","title":"Base.length","text":"Alias for pipe_length.\n\nThis makes length(pipe) meaningful for InsulatedPipe and matches the package export list.\n\n\n\n\n\n","category":"method"},{"location":"API/#DHNetworkSimulator.inner_diameter","page":"API","title":"DHNetworkSimulator.inner_diameter","text":"Return pipe inner diameter in meters.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.heat_resistance_forward","page":"API","title":"DHNetworkSimulator.heat_resistance_forward","text":"Return thermal resistance (supply direction) in m·K/W.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.heat_resistance_backward","page":"API","title":"DHNetworkSimulator.heat_resistance_backward","text":"Return thermal resistance (return direction) in m·K/W.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.water_velocity","page":"API","title":"DHNetworkSimulator.water_velocity","text":"Compute water velocity in an InsulatedPipe in m/s.\n\nReturns missing if the pipe has no mass flow set.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.water_velocities","page":"API","title":"DHNetworkSimulator.water_velocities","text":"Compute water velocities for all pipe edges in the network.\n\nReturns a dictionary keyed by (src_label, dst_label).\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.collect_exiting_water_plugs!","page":"API","title":"DHNetworkSimulator.collect_exiting_water_plugs!","text":"Collect plugs that exit a pipe over one time step.\n\nGiven a plug queue plugs (front = pipe outlet), mass flow mass_flow [kg/s], and time step Δt [s], this pops and (if needed) splits plugs so that the returned vector has total mass approximately mass_flow*Δt.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.combine_plugs","page":"API","title":"DHNetworkSimulator.combine_plugs","text":"Combine multiple plugs into a single mass-weighted average plug.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.merge_same_temperature_plugs!","page":"API","title":"DHNetworkSimulator.merge_same_temperature_plugs!","text":"Merge consecutive plugs whose temperatures are nearly equal.\n\nThis simplifies a plug queue in-place by combining adjacent plugs when abs(ΔT) < tol.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.merge_water_plug_vectors!","page":"API","title":"DHNetworkSimulator.merge_water_plug_vectors!","text":"Merge multiple plug sequences into one sequence (return-side merging).\n\nThis is used when multiple return streams meet at a junction: it produces a single plug sequence that is consistent with the combined mass.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.check_network!","page":"API","title":"DHNetworkSimulator.check_network!","text":"Check network upon start of the simulation.\n\nupdate neighbor dicts if needed\nif there was a change, check that\nthere is exactly one producer node\nthere are no cycles in the network (DAG)\nall nodes are reachable from the producer node\nload nodes are leaves\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.set_relative_mass_flows!","page":"API","title":"DHNetworkSimulator.set_relative_mass_flows!","text":"Compute and assign relative mass-flow split coefficients m_rel on edges.\n\nThis performs a post-order traversal from leaves to root and sets, for each edge leading into a node, the sum of m_rel values required downstream.\n\nThis is an internal step of steady_state_hydronynamics!.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.set_absolute_mass_flows!","page":"API","title":"DHNetworkSimulator.set_absolute_mass_flows!","text":"Assign absolute mass flows throughout the network.\n\nGiven the producer mass flow mass_flow_source [kg/s] and relative edge split coefficients (see set_relative_mass_flows!), this propagates mass flows from root to leaves and writes mass_flow to both nodes and pipe edges.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.steady_state_hydronynamics!","page":"API","title":"DHNetworkSimulator.steady_state_hydronynamics!","text":"Compute steady-state hydraulics for a Network.\n\nThis updates the mass-flow distribution throughout the network for a given producer (source) mass flow mass_flow_source [kg/s].\n\nInternally it:\n\ncomputes relative flow splits (set_relative_mass_flows!),\nassigns absolute mass flows on edges and nodes (set_absolute_mass_flows!).\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.fill_pipes_with_initial_temperature!","page":"API","title":"DHNetworkSimulator.fill_pipes_with_initial_temperature!","text":"Initialize all pipe plug queues with uniform temperatures.\n\nFills every InsulatedPipe in the network with a single plug in the forward queue at temperature_f and a single plug in the backward queue at temperature_b.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.time_step_thermal_dynamics!","page":"API","title":"DHNetworkSimulator.time_step_thermal_dynamics!","text":"Advance thermal dynamics by one time step.\n\nThis is a convenience wrapper used for manual stepping outside of run_simulation. It performs:\n\nforward (supply) plug advection from producer to loads,\nload power consumption and cooling,\nbackward (return) advection back to the producer.\n\nArguments\n\nnw::Network: the network (must have steady-state mass flows already computed, e.g. via steady_state_hydronynamics!).\nΔt::Float64: time step in seconds.\ninput::ProducerOutput: producer setpoints for this step.\n\nKeyword Arguments\n\nambient_temperature: outdoor/ambient temperature in °C (or nothing). When nothing, a default of 15°C is used for load demand.\n\nReturns\n\n(output_plugs, incoming_plug) where output_plugs maps load labels to their inlet plug, and incoming_plug represents the return temperature entering the producer.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.set_load_params!","page":"API","title":"DHNetworkSimulator.set_load_params!","text":"Set load parameters for one load node.\n\nCurrently this sets only the relative mass-flow coefficient m_rel.\n\n\n\n\n\nSet load parameters for multiple load nodes.\n\nload_params maps load_label => m_rel.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.power_consumption","page":"API","title":"DHNetworkSimulator.power_consumption","text":"Compute load power demand as a function of outdoor temperature.\n\nReturns power in Watts.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.consume_power!","page":"API","title":"DHNetworkSimulator.consume_power!","text":"Reduce a plug temperature by consuming power over a time step.\n\npower is in Watts and Δt is in seconds. Updates p in-place.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.run_simulation","page":"API","title":"DHNetworkSimulator.run_simulation","text":"Run a quasi-dynamic simulation of a district heating network.\n\nrun_simulation(network, sim_time, policy; T0_f=60.0, T0_b=25.0, ambient_temperature=nothing)\n\nThis is the main entry point for time stepping.\n\nREPEAT for N time steps:\n\ncomputes a steady-state hydraulic solution (mass flow distribution),\nadvances thermal dynamics using the plug-flow method:\nforward/supply advection producer → loads,\nheat consumption at loads,\nbackward/return advection loads → producer,\nheat losses to ambient.\n\nSee Plug method for the underlying model.\n\nOutput\n\nSimulationResults struct containing time series of temperatures, flows, and powers for all nodes and edges.\n\nArguments\n\nnetwork::Network: prepared network (producer/load nodes identified, pipes attached).\nsim_time: equally spaced time vector.\nVector{Float64}: time in seconds.\nVector{DateTime}: timestamps (Δt is interpreted in seconds).\npolicy::Function: callback returning ProducerOutput.\nSignature: policy(t, Tₐ, T_back)::ProducerOutput\nTₐ is ambient temperature at time t or nothing.\nT_back is the return temperature entering the producer (in previous time step k-1).\n\nKeyword Arguments\n\nT0_f: initial temperature forward part of the network (producer → loads) (°C).\nT0_b: initial temperature in backward part of the network (loads → producer) (°C).\nambient_temperature: optional Vector{Float64} of ambient (outdoor/atmospheric) temperatures (°C), length must match sim_time.\n\nReturns\n\nSimulationResults: time series of temperatures, flows, and powers.\n\nNotes\n\nThe network structure is validated once at the start via check_network!.\nTime steps must be equally spaced.\n\n\n\n\n\n","category":"function"},{"location":"API/#DHNetworkSimulator.plot_simulation_results","page":"API","title":"DHNetworkSimulator.plot_simulation_results","text":"Plot time series from SimulationResults.\n\nplot_simulation_results is a small helper around Plots.jl that plots one physical variable either:\n\nfor selected load labels, or\nfor the producer (for producer-only variables).\n\nplot_simulation_results(sr::SimulationResults, physical_var::Symbol; kwargs...)\nplot_simulation_results(sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)\nplot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, physical_var::Symbol; kwargs...)\nplot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)\n\nArguments\n\nsr::SimulationResults: simulation output from run_simulation.\nlabels::Vector{String}: load labels to include in plot (only used for load variables),                           if not provided, all load labels are plotted.\nphysical_var::Symbol: what values to plot.   Supported options are:\ntemperatures: :T_load_in, :T_load_out, :T_producer_in, :T_producer_out\nmass flows: :mass_flow_load, :mass_flow_producer\npowers: :power_load, :power_producer\nplot::Plots.Plot{Plots.GRBackend}: an existing plot to add lines to,                                      if not provided, a new plot is created.\n\nKeyword Arguments\n\nkwargs...: forwarded to Plots.plot! (e.g. linewidth, color, legend, ...).\n\nReturns\n\nThe Plots.Plot object.\n\nNotes\n\nIf sr[:time] is Vector{Float64}, the x-axis is converted from seconds to minutes.\n:power_producer has length N-1 and is plotted against time[1:end-1].\nWhen plotting producer variables, the line style defaults to dashed (unless you override linestyle).\n\nExamples\n\nsr = run_simulation(network, t, policy)\n\nplot_simulation_results(sr, :T_load_in)\nplot_simulation_results(sr, [\"L1\", \"L2\"], :mass_flow_load)\nplot_simulation_results(sr, :power_producer)\n\n\n\n\n\n","category":"function"}]
}
