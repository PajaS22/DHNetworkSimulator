<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DHNetworkSimulator</title><meta name="title" content="API · DHNetworkSimulator"/><meta property="og:title" content="API · DHNetworkSimulator"/><meta property="twitter:title" content="API · DHNetworkSimulator"/><meta name="description" content="Documentation for DHNetworkSimulator."/><meta property="og:description" content="Documentation for DHNetworkSimulator."/><meta property="twitter:description" content="Documentation for DHNetworkSimulator."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DHNetworkSimulator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Plug_method/">Plug Method</a></li><li><span class="tocitem">Network</span><ul><li><a class="tocitem" href="../Network/">Network</a></li><li><a class="tocitem" href="../types/">Nodes and Edges</a></li></ul></li><li><a class="tocitem" href="../simulation/">Simulation</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Core-types"><span>Core types</span></a></li><li><a class="tocitem" href="#Network-construction-and-manipulation"><span>Network construction and manipulation</span></a></li><li><a class="tocitem" href="#Graph-interface"><span>Graph interface</span></a></li><li><a class="tocitem" href="#Visualization-and-printing"><span>Visualization and printing</span></a></li><li><a class="tocitem" href="#Pipe-geometry-and-hydraulics-helpers"><span>Pipe geometry and hydraulics helpers</span></a></li><li><a class="tocitem" href="#Plug-method-helpers"><span>Plug-method helpers</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#External-helpers"><span>External helpers</span></a></li></ul></li><li><a class="tocitem" href="../search/">Search</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PajaS22/DHNetworkSimulator" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This page collects the public API of DHNetworkSimulator in one place.</p><h2 id="Core-types"><a class="docs-heading-anchor" href="#Core-types">Core types</a><a id="Core-types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-types" title="Permalink"></a></h2><h3 id="Network-and-topology"><a class="docs-heading-anchor" href="#Network-and-topology">Network and topology</a><a id="Network-and-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Network-and-topology" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.Network"><a class="docstring-binding" href="#DHNetworkSimulator.Network"><code>DHNetworkSimulator.Network</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Network type representing a district heating network.</p><pre><code class="language-julia hljs">mutable struct Network{T&lt;:Integer} &lt;: AbstractGraph{T}
    mg::MetaGraph                               # MetaGraph from MetaGraphs.jl, it contains the network 
                                                    structure and node and edge data
    producer_label::Union{Nothing, String}      # Label of the producer node
    load_labels::Set{String}                    # Labels of the consumer nodes
    neighbor_dicts::NeighborDicts               # Mappings to inneghbors and outneighbors for efficient access during simulation
end</code></pre><p><strong>Fields</strong></p><ul><li><code>mg</code>: a MetaGraphsNext <code>MetaGraph</code> that contains the directed topology and stores node/edge data.</li><li><code>producer_label</code>: label of the single producer node (or <code>nothing</code> if not yet set).</li><li><code>load_labels</code>: a set of labels for load nodes.</li><li><code>neighbor_dicts</code>: cached neighbor lists used to reduce allocations during simulation.</li></ul><p><strong>Constructors</strong></p><ul><li><code>Network()</code>: Creates an empty DH network with no nodes or edges.</li><li><code>Network(g::DiGraph)</code>: Creates a DH network from an existing directed graph structure (&#39;Graphs.jl&#39;).                        Nodes and edges are initialized with EmptyNode and EmptyEdge data.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.NeighborDicts"><a class="docstring-binding" href="#DHNetworkSimulator.NeighborDicts"><code>DHNetworkSimulator.NeighborDicts</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Mappings to inneghbors and outneighbors for efficient access during simulation, stored in the Network struct.</p><p>When calling functions <code>outneighbors(nw, label)</code> or <code>inneighbors(nw, label)</code>,  there is no need to scan through the graph and collect neighbors,  instead we can directly access the pre-computed neighbor lists in the dictionaries. This significantly lowers the number of allocations during simulation, because there is a lot of places where we need to access neighbors of a node.</p><p>The network is static during the simulation, so we can compute these neighbor lists once before the simulation starts and then reuse them.</p><pre><code class="language-julia hljs">mutable struct NeighborDicts
    outneighbors::Dict{String, Vector{String}}       # mapping nodes to outneighbors for efficient access in simulation
    inneighbors::Dict{String, Vector{String}}        # mapping nodes to inneighbors for efficient access in simulation
    need_rebuild::Bool                               # flag to indicate if neighbor dicts need to be rebuilt before simulation
end</code></pre><ul><li><code>need_rebuild</code> flag is used to indicate when the neighbor dicts need to be updated  (e.g., after adding/removing nodes or edges), so that we can avoid unnecessary   rebuilding during multiple modifications.</li></ul><p><strong>Constructor</strong></p><ul><li><code>NeighborDicts()</code>: Creates an instance of NeighborDicts with empty dictionaries and the need_rebuild flag set to true.</li></ul></div></section></details></article><h3 id="Nodes-and-edges"><a class="docs-heading-anchor" href="#Nodes-and-edges">Nodes and edges</a><a id="Nodes-and-edges-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-and-edges" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.NodeType"><a class="docstring-binding" href="#DHNetworkSimulator.NodeType"><code>DHNetworkSimulator.NodeType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract supertype for all node types in a district heating network.</p><p>Concrete node types describe the <em>role</em> of a vertex in the directed network:</p><ul><li><code>ProducerNode</code>: heat source (root)</li><li><code>JunctionNode</code>: branching/merging point</li><li><code>LoadNode</code>: heat consumer (typically a leaf)</li><li><code>EmptyNode</code>: placeholder used during construction</li></ul><p>All concrete node types store a <code>common::NodeCommon</code> field with metadata such as <code>info</code>, <code>position</code>, and (optionally) the current steady-state <code>mass_flow</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.EdgeType"><a class="docstring-binding" href="#DHNetworkSimulator.EdgeType"><code>DHNetworkSimulator.EdgeType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract supertype for all edge types in a district heating network.</p><p>Edges represent physical connections between nodes. In this package the primary edge type is <code>InsulatedPipe</code>. <code>EmptyEdge</code> is used as a placeholder (e.g., when building a network from a bare topology).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.NodeCommon"><a class="docstring-binding" href="#DHNetworkSimulator.NodeCommon"><code>DHNetworkSimulator.NodeCommon</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Common data for all node types in the DH network.</p><p><code>NodeCommon</code> contains fields that are useful across producers, junctions, and loads.</p><pre><code class="language-julia hljs">mutable struct NodeCommon
    info::String
    position::Union{Missing, Tuple{Float64, Float64}}   # (x, y) coordinates
    mass_flow::Union{Missing, Float64}                  # [kg/s]
end</code></pre><p><strong>Fields</strong></p><ul><li><code>info::String</code>: human-readable label shown in printing/plots.</li><li><code>position::Union{Missing, Tuple{Float64, Float64}}</code>: optional <code>(x,y)</code> coordinates (used by visualization).</li><li><code>mass_flow::Union{Missing, Float64}</code>: steady-state mass flow through the node in kg/s.</li></ul><p><strong>Notes</strong></p><ul><li>Many fields use <code>missing</code> to represent “not initialized / not computed yet”.</li><li>During simulation, mass flows are usually filled by <code>steady_state_hydronynamics!</code>.</li></ul><p><strong>Constructors</strong></p><ul><li><code>NodeCommon(info::String)</code></li><li><code>NodeCommon(info::String, position::Tuple{Float64, Float64})</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.ProducerNode"><a class="docstring-binding" href="#DHNetworkSimulator.ProducerNode"><code>DHNetworkSimulator.ProducerNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>DH network node representing a producer (heat source).</p><p>There may be only one producer in the network, and it is identified by its label (producer_label field in Network).</p><p>In simulations, the producer’s mass flow and supply temperature are usually provided by a control policy (see <code>ProducerOutput</code> and <code>run_simulation</code>).</p><pre><code class="language-julia hljs">struct ProducerNode &lt;: NodeType
    common::NodeCommon
end</code></pre><p><strong>Constructors</strong></p><ul><li><code>ProducerNode(info::String)</code></li><li><code>ProducerNode(info::String, position::Tuple{Float64, Float64})</code></li><li><code>ProducerNode(position::Tuple{Float64, Float64})</code></li><li><code>ProducerNode()</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.JunctionNode"><a class="docstring-binding" href="#DHNetworkSimulator.JunctionNode"><code>DHNetworkSimulator.JunctionNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>DH network node representing a junction.</p><p>Junctions are internal vertices that connect multiple pipes but do not directly produce or consume heat. They are where flow splits (supply direction) or merges (return direction).</p><pre><code class="language-julia hljs">struct JunctionNode &lt;: NodeType
    common::NodeCommon
end</code></pre><p><strong>Constructors</strong></p><ul><li><code>JunctionNode(info::String)</code></li><li><code>JunctionNode(info::String, position::Tuple{Float64, Float64})</code></li><li><code>JunctionNode(position::Tuple{Float64, Float64})</code></li><li><code>JunctionNode()</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.LoadNode"><a class="docstring-binding" href="#DHNetworkSimulator.LoadNode"><code>DHNetworkSimulator.LoadNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>DH network node representing a load (consumer).</p><p>The <code>load</code> field defines a quadratic power-demand curve as a function of ambient temperature <span>$T_a$</span>:</p><p><span>$P(T_a) = p_0 + p_1 T_a + p_2 T_a^2,$</span> where the power is in kW and the ambient temperature is in °C.</p><p>The <code>m_rel</code> field is a <em>relative mass-flow coefficient</em> used when splitting flows at a junction while solving steady state flow; it is specified for leaf nodes and propagated to upstream edges.</p><pre><code class="language-julia hljs">mutable struct LoadNode &lt;: NodeType
    common::NodeCommon
    load::Union{Missing, NTuple{3, Float64}}     # Heat load function in kW, P(Tₐ) = p₀ + p₁*Tₐ + p₂*Tₐ²
    m_rel::Union{Missing, Float64}               # Relative mass flow coefficient (for branching nodes)
end</code></pre><p><strong>Constructors</strong></p><ul><li><code>LoadNode(info::String; load=DEFAULT_LOAD)</code>: Creates a LoadNode with the specified info string and an optional load function (default is a typical load curve).</li><li><code>LoadNode(info::String, position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)</code></li><li><code>LoadNode(info::String, position::Tuple{Float64, Float64}, load::NTuple{3, Float64})</code></li><li><code>LoadNode(info::String, position::Tuple{Float64, Float64}, m_rel::Float64; load=DEFAULT_LOAD)</code></li><li><code>LoadNode(position::Tuple{Float64, Float64}; load=DEFAULT_LOAD)</code></li><li><code>LoadNode(; load=DEFAULT_LOAD)</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.EmptyNode"><a class="docstring-binding" href="#DHNetworkSimulator.EmptyNode"><code>DHNetworkSimulator.EmptyNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Placeholder node type.</p><p><code>EmptyNode</code> is used when constructing a <code>Network</code> from a bare topology (e.g. <code>Network(graph::DiGraph)</code>). Replace placeholders with real node types (<code>ProducerNode</code>, <code>JunctionNode</code>, <code>LoadNode</code>) before running simulations.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.PipeParams"><a class="docstring-binding" href="#DHNetworkSimulator.PipeParams"><code>DHNetworkSimulator.PipeParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Physical parameters of a pipe (constant during simulation).</p><p>These parameters describe geometry and heat-loss characteristics.</p><pre><code class="language-julia hljs">struct PipeParams                       # unchanging physical parameters of the pipe
    length::Float64                     # Length of the pipe [m]
    inner_diameter::Float64             # Inner diameter [m]
    heat_resistance_forward::Float64    # Thermal resistance [m*K/W]
    heat_resistance_backward::Float64   # Thermal resistance [m*K/W]
end</code></pre><p><strong>Fields</strong></p><ul><li><code>length</code> [m]</li><li><code>inner_diameter</code> [m]</li><li><code>heat_resistance_forward</code> [m·K/W]: thermal resistance for the supply direction</li><li><code>heat_resistance_backward</code> [m·K/W]: thermal resistance for the return direction</li></ul><p><strong>Constructors</strong></p><ul><li><code>PipeParams(length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)</code></li><li><code>PipeParams(length::Float64, inner_diameter::Float64)</code>: uses default heat resistance values based on typical insulation properties.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.InsulatedPipe"><a class="docstring-binding" href="#DHNetworkSimulator.InsulatedPipe"><code>DHNetworkSimulator.InsulatedPipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>DH network edge representing an insulated pipe.</p><p><code>InsulatedPipe</code> transports water between nodes and stores both physical parameters and the current hydraulic/thermal state.</p><pre><code class="language-julia hljs">mutable struct InsulatedPipe &lt;: EdgeType
    info::String
    physical_params::PipeParams
    mass_flow::Union{Missing, Float64}  # Mass flow in [kg/s]
    m_rel::Union{Missing, Float64}      # Relative mass flow coefficient (for branching pipes)
    plugs_f::Vector{Plug}               # Queue of plugs in the pipe (forward direction)
    plugs_b::Vector{Plug}               # Queue of plugs in the pipe (backward direction)
end</code></pre><p><strong>Fields</strong></p><ul><li>`physical_params: geometry and heat-loss parameters.</li><li><code>mass_flow: mass flow in kg/s (typically computed by</code>steady<em>state</em>hydronynamics!`).</li><li>`m_rel: relative flow coefficient used for splitting at junctions.</li><li>`plugs_f: plug queue for the forward (supply) direction.</li><li>`plugs_b: plug queue for the backward (return) direction.</li></ul><p><strong>Constructors</strong></p><ul><li><code>InsulatedPipe(info::String; length::Float64, inner_diameter::Float64, heat_resistance_forward::Float64, heat_resistance_backward::Float64)</code></li><li><code>InsulatedPipe(info::String, params::PipeParams)</code></li><li><code>InsulatedPipe(params::PipeParams)</code></li><li><code>InsulatedPipe(length::Real)</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.Plug"><a class="docstring-binding" href="#DHNetworkSimulator.Plug"><code>DHNetworkSimulator.Plug</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A single water plug used by the plug-method pipe model.</p><p>A <code>Plug</code> represents a mass of water inside a pipe that is assumed to have uniform temperature. Plugs are advected through pipes during time stepping and may be split/merged.</p><pre><code class="language-julia hljs">mutable struct Plug
    T::Float64  # Temperature at the plug [°C]
    m::Float64  # mass of the plug [kg]
end</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.EmptyEdge"><a class="docstring-binding" href="#DHNetworkSimulator.EmptyEdge"><code>DHNetworkSimulator.EmptyEdge</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Placeholder edge type.</p><p><code>EmptyEdge</code> is used when constructing a <code>Network</code> from a topology without pipe parameters. Replace it with <code>InsulatedPipe</code> before running simulations.</p></div></section></details></article><h3 id="Simulation-I/O"><a class="docs-heading-anchor" href="#Simulation-I/O">Simulation I/O</a><a id="Simulation-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-I/O" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.ProducerOutput"><a class="docstring-binding" href="#DHNetworkSimulator.ProducerOutput"><code>DHNetworkSimulator.ProducerOutput</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Control input returned by a simulation policy.</p><p><code>ProducerOutput</code> represents the producer setpoints for one time step.</p><pre><code class="language-julia hljs">struct ProducerOutput
    mass_flow::Float64
    temperature::Float64
end</code></pre><p><strong>Fields</strong></p><ul><li><code>mass_flow</code>: total mass flow injected into the network in kg/s.</li><li><code>temperature</code>: producer outlet (supply) temperature in °C.</li></ul><p><strong>Usage</strong></p><p>The <code>policy</code> passed to <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a> must return a <code>ProducerOutput</code>:</p><pre><code class="language-julia hljs">function policy(t, Tₐ, T_back)
    return ProducerOutput(mass_flow=15.0, temperature=90.0)
end</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.SimulationResults"><a class="docstring-binding" href="#DHNetworkSimulator.SimulationResults"><code>DHNetworkSimulator.SimulationResults</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Results of a simulation run.</p><p><code>SimulationResults</code> stores the time series produced by <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a>.</p><pre><code class="language-julia hljs">struct SimulationResults
        time::Union{Vector{Float64}, Vector{DateTime}}
        mass_flow_load::Matrix{Float64}
        mass_flow_producer::Vector{Float64}
        T_load_in::Matrix{Float64}
        T_load_out::Matrix{Float64}
        T_producer_in::Vector{Float64}
        T_producer_out::Vector{Float64}
        power_load::Matrix{Float64}
        power_producer::Vector{Float64}
        load_labels::Dict{String, Int}
end</code></pre><p><strong>Fields</strong></p><ul><li><code>time</code>: simulation time vector.<ul><li><code>Vector{Float64}</code>: time in seconds.</li><li><code>Vector{DateTime}</code>: absolute timestamps.</li></ul></li><li><code>mass_flow_load</code>: load mass flows in kg/s. Size <code>N × nloads</code>.</li><li><code>mass_flow_producer</code>: producer mass flow in kg/s. Length <code>N</code>.</li><li><code>T_load_in</code>: temperature entering each load (supply side) in °C. Size <code>N × nloads</code>.</li><li><code>T_load_out</code>: temperature leaving each load (return side) in °C. Size <code>N × nloads</code>.</li><li><code>T_producer_in</code>: return temperature entering the producer in °C. Length <code>N</code>.</li><li><code>T_producer_out</code>: supply temperature leaving the producer in °C. Length <code>N</code>.</li><li><code>power_load</code>: load power consumption in kW. Size <code>N × nloads</code>.</li><li><code>power_producer</code>: producer power output in MW (computed from mass flow and ΔT). Length <code>N-1</code>.</li><li><code>load_labels</code>: mapping from load label to column index used in the <code>*_load</code> matrices.</li></ul><p><strong>Indexing</strong></p><p>Convenience accessors are provided:</p><ul><li><code>sr[:time]</code> returns the time vector.</li><li><code>sr[:load_labels]</code> returns the load labels.</li><li><code>sr[:load_labels_dict]</code> returns the label→column dictionary.</li><li><code>sr[&quot;L1&quot;, :T_load_in]</code> returns the time series for that load L1 (a vector).</li></ul><p><strong>Notes</strong></p><ul><li>All matrices are organized as <code>(time step, load index)</code>.</li><li><code>power_producer</code> has length <code>N-1</code> because the producer heats the water that entered in in <em>previous!</em> time step.</li></ul></div></section></details></article><h2 id="Network-construction-and-manipulation"><a class="docs-heading-anchor" href="#Network-construction-and-manipulation">Network construction and manipulation</a><a id="Network-construction-and-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Network-construction-and-manipulation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.fill_physical_params!"><a class="docstring-binding" href="#DHNetworkSimulator.fill_physical_params!"><code>DHNetworkSimulator.fill_physical_params!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Fill the physical parameters of the edges in the network based on the provided <code>pipe_params</code> dictionary.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.fill_node_positions!"><a class="docstring-binding" href="#DHNetworkSimulator.fill_node_positions!"><code>DHNetworkSimulator.fill_node_positions!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Fill the positions of the nodes in the network based on the provided <code>node_positions</code> dictionary.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.fill_load_specs!"><a class="docstring-binding" href="#DHNetworkSimulator.fill_load_specs!"><code>DHNetworkSimulator.fill_load_specs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Fill the load specifications: (power coefficients and relative mass flow)</p><ul><li><code>pwr_coefs</code> specifies tuples of power coefficients (p0, p1, p2) for the quadratic power curve.</li><li><code>m_r</code> specifies relative mass flow coefficients</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.name_nodes!"><a class="docstring-binding" href="#DHNetworkSimulator.name_nodes!"><code>DHNetworkSimulator.name_nodes!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Rename the nodes in the network according to the provided <code>labels</code> vector.</p><p>The order of labels should correspond to the order in which were the nodes added to the graph (default labels are &quot;1&quot;, &quot;2&quot;, ..., &quot;n&quot;).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.identify_producer_and_loads!"><a class="docstring-binding" href="#DHNetworkSimulator.identify_producer_and_loads!"><code>DHNetworkSimulator.identify_producer_and_loads!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Identify the producer and load nodes in the network.</p><p>This comes in handy in situation when the graph was provided without node types (e.g. from a file)  and we want to classify the nodes based on their connectivity.</p><p>This function classifies nodes based on their degree:</p><ul><li>Nodes with outdegree &gt; 0 and indegree == 0 are classified as <code>ProducerNode</code> (source).</li><li>Nodes with outdegree == 0 and indegree &gt; 0 are classified as <code>LoadNode</code> (sink).</li><li>Nodes with outdegree &gt; 0 and indegree &gt; 0 are classified as <code>JunctionNode</code>.</li><li>Nodes with outdegree == 0 and indegree == 0 are classified as <code>EmptyNode</code> (isolated).   these should not appear in a valid network!</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.has_label"><a class="docstring-binding" href="#DHNetworkSimulator.has_label"><code>DHNetworkSimulator.has_label</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return <code>true</code> if <code>label</code> exists as a node label in the network.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.index_for"><a class="docstring-binding" href="#DHNetworkSimulator.index_for"><code>DHNetworkSimulator.index_for</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return the internal vertex index for a given node <code>label</code>.</p><p>This is mainly useful when interacting with Graphs.jl functions that operate on integer vertex indices.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.rem_node!"><a class="docstring-binding" href="#DHNetworkSimulator.rem_node!"><code>DHNetworkSimulator.rem_node!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Remove a node from a <code>Network</code> by its string label.</p><p>This updates <code>producer_label</code> / <code>load_labels</code> as needed and marks neighbor caches dirty.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.rename_node!"><a class="docstring-binding" href="#DHNetworkSimulator.rename_node!"><code>DHNetworkSimulator.rename_node!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Rename a node label in-place.</p><p>This preserves the node data and all incident edges by removing the old label and re-inserting under <code>new_label</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.vertices_data"><a class="docstring-binding" href="#DHNetworkSimulator.vertices_data"><code>DHNetworkSimulator.vertices_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return a vector of all node data stored in a <code>Network</code> (in label order).</p></div></section><section><div><p>Return a vector of all node data stored in a MetaGraphsNext <code>MetaGraph</code> (in label order).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.edges_data"><a class="docstring-binding" href="#DHNetworkSimulator.edges_data"><code>DHNetworkSimulator.edges_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return a vector of all edge data stored in a <code>Network</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.all_labels"><a class="docstring-binding" href="#DHNetworkSimulator.all_labels"><code>DHNetworkSimulator.all_labels</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return all vertex labels in the network.</p></div></section></details></article><h2 id="Graph-interface"><a class="docs-heading-anchor" href="#Graph-interface">Graph interface</a><a id="Graph-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-interface" title="Permalink"></a></h2><p><code>Network</code> implements parts of the Graphs.jl interface (e.g., <code>nv</code>, <code>ne</code>, <code>vertices</code>, <code>edges</code>, <code>outdegree</code>, <code>indegree</code>, <code>neighbors</code>).</p><p>These label-based helpers are provided by DHNetworkSimulator:</p><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.outneighbors"><a class="docstring-binding" href="#DHNetworkSimulator.outneighbors"><code>DHNetworkSimulator.outneighbors</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return outgoing neighbor labels for a node label.</p><p>This is the <code>Network</code>-specific overload that returns <strong>string labels</strong> (not Graphs.jl vertex indices). Neighbor caches are rebuilt automatically when needed.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.inneighbors"><a class="docstring-binding" href="#DHNetworkSimulator.inneighbors"><code>DHNetworkSimulator.inneighbors</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return incoming neighbor labels for a node label.</p><p>This is the <code>Network</code>-specific overload that returns <strong>string labels</strong> (not Graphs.jl vertex indices). Neighbor caches are rebuilt automatically when needed.</p></div></section></details></article><h2 id="Visualization-and-printing"><a class="docs-heading-anchor" href="#Visualization-and-printing">Visualization and printing</a><a id="Visualization-and-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-and-printing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.visualize_graph!"><a class="docstring-binding" href="#DHNetworkSimulator.visualize_graph!"><code>DHNetworkSimulator.visualize_graph!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Visualize a <code>Network</code> using GraphMakie.</p><p>Returns <code>(figure, axis, plot)</code> from <code>GraphMakie.graphplot</code>. If edge mass flows have been computed (e.g. via <code>steady_state_hydronynamics!</code>), the plot also shows flow-dependent edge styling.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.edge_info"><a class="docstring-binding" href="#DHNetworkSimulator.edge_info"><code>DHNetworkSimulator.edge_info</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Human-readable edge label used by default in <code>visualize_graph!</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.edge_info_hover"><a class="docstring-binding" href="#DHNetworkSimulator.edge_info_hover"><code>DHNetworkSimulator.edge_info_hover</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Human-readable edge label used on hover in <code>visualize_graph!</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.edge_infos"><a class="docstring-binding" href="#DHNetworkSimulator.edge_infos"><code>DHNetworkSimulator.edge_infos</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Vectorized helper returning labels for all edges in a <code>MetaGraph</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.print_nodes"><a class="docstring-binding" href="#DHNetworkSimulator.print_nodes"><code>DHNetworkSimulator.print_nodes</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Print all nodes of the network with their stored node data.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.print_edges"><a class="docstring-binding" href="#DHNetworkSimulator.print_edges"><code>DHNetworkSimulator.print_edges</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Print all edges of the network with their stored edge data.</p></div></section></details></article><h2 id="Pipe-geometry-and-hydraulics-helpers"><a class="docs-heading-anchor" href="#Pipe-geometry-and-hydraulics-helpers">Pipe geometry and hydraulics helpers</a><a id="Pipe-geometry-and-hydraulics-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Pipe-geometry-and-hydraulics-helpers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.pipe_length"><a class="docstring-binding" href="#DHNetworkSimulator.pipe_length"><code>DHNetworkSimulator.pipe_length</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return physical pipe length in meters.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{InsulatedPipe}"><a class="docstring-binding" href="#Base.length-Tuple{InsulatedPipe}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Alias for <a href="#DHNetworkSimulator.pipe_length"><code>pipe_length</code></a>.</p><p>This makes <code>length(pipe)</code> meaningful for <code>InsulatedPipe</code> and matches the package export list.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.inner_diameter"><a class="docstring-binding" href="#DHNetworkSimulator.inner_diameter"><code>DHNetworkSimulator.inner_diameter</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return pipe inner diameter in meters.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.heat_resistance_forward"><a class="docstring-binding" href="#DHNetworkSimulator.heat_resistance_forward"><code>DHNetworkSimulator.heat_resistance_forward</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return thermal resistance (supply direction) in m·K/W.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.heat_resistance_backward"><a class="docstring-binding" href="#DHNetworkSimulator.heat_resistance_backward"><code>DHNetworkSimulator.heat_resistance_backward</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return thermal resistance (return direction) in m·K/W.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.water_velocity"><a class="docstring-binding" href="#DHNetworkSimulator.water_velocity"><code>DHNetworkSimulator.water_velocity</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute water velocity in an <code>InsulatedPipe</code> in m/s.</p><p>Returns <code>missing</code> if the pipe has no mass flow set.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.water_velocities"><a class="docstring-binding" href="#DHNetworkSimulator.water_velocities"><code>DHNetworkSimulator.water_velocities</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute water velocities for all pipe edges in the network.</p><p>Returns a dictionary keyed by <code>(src_label, dst_label)</code>.</p></div></section></details></article><h2 id="Plug-method-helpers"><a class="docs-heading-anchor" href="#Plug-method-helpers">Plug-method helpers</a><a id="Plug-method-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Plug-method-helpers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.collect_exiting_water_plugs!"><a class="docstring-binding" href="#DHNetworkSimulator.collect_exiting_water_plugs!"><code>DHNetworkSimulator.collect_exiting_water_plugs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Collect plugs that exit a pipe over one time step.</p><p>Given a plug queue <code>plugs</code> (front = pipe outlet), mass flow <code>mass_flow</code> [kg/s], and time step <code>Δt</code> [s], this pops and (if needed) splits plugs so that the returned vector has total mass approximately <code>mass_flow*Δt</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.combine_plugs"><a class="docstring-binding" href="#DHNetworkSimulator.combine_plugs"><code>DHNetworkSimulator.combine_plugs</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Combine multiple plugs into a single mass-weighted average plug.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.merge_same_temperature_plugs!"><a class="docstring-binding" href="#DHNetworkSimulator.merge_same_temperature_plugs!"><code>DHNetworkSimulator.merge_same_temperature_plugs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Merge consecutive plugs whose temperatures are nearly equal.</p><p>This simplifies a plug queue in-place by combining adjacent plugs when <code>abs(ΔT) &lt; tol</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.merge_water_plug_vectors!"><a class="docstring-binding" href="#DHNetworkSimulator.merge_water_plug_vectors!"><code>DHNetworkSimulator.merge_water_plug_vectors!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Merge multiple plug sequences into one sequence (return-side merging).</p><p>This is used when multiple return streams meet at a junction: it produces a single plug sequence that is consistent with the combined mass.</p></div></section></details></article><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.check_network!"><a class="docstring-binding" href="#DHNetworkSimulator.check_network!"><code>DHNetworkSimulator.check_network!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Check network upon start of the simulation.</p><ol><li>update neighbor dicts if needed</li><li>if there was a change, check that<ul><li>there is exactly one producer node</li><li>there are no cycles in the network (DAG)</li><li>all nodes are reachable from the producer node</li><li>load nodes are leaves</li></ul></li></ol></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.set_relative_mass_flows!"><a class="docstring-binding" href="#DHNetworkSimulator.set_relative_mass_flows!"><code>DHNetworkSimulator.set_relative_mass_flows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute and assign relative mass-flow split coefficients <code>m_rel</code> on edges.</p><p>This performs a post-order traversal from leaves to root and sets, for each edge leading into a node, the sum of <code>m_rel</code> values required downstream.</p><p>This is an internal step of <a href="#DHNetworkSimulator.steady_state_hydronynamics!"><code>steady_state_hydronynamics!</code></a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.set_absolute_mass_flows!"><a class="docstring-binding" href="#DHNetworkSimulator.set_absolute_mass_flows!"><code>DHNetworkSimulator.set_absolute_mass_flows!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Assign absolute mass flows throughout the network.</p><p>Given the producer mass flow <code>mass_flow_source</code> [kg/s] and relative edge split coefficients (see <a href="#DHNetworkSimulator.set_relative_mass_flows!"><code>set_relative_mass_flows!</code></a>), this propagates mass flows from root to leaves and writes <code>mass_flow</code> to both nodes and pipe edges.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.steady_state_hydronynamics!"><a class="docstring-binding" href="#DHNetworkSimulator.steady_state_hydronynamics!"><code>DHNetworkSimulator.steady_state_hydronynamics!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute steady-state hydraulics for a <code>Network</code>.</p><p>This updates the mass-flow distribution throughout the network for a given producer (source) mass flow <code>mass_flow_source</code> [kg/s].</p><p>Internally it:</p><ol><li>computes relative flow splits (<code>set_relative_mass_flows!</code>),</li><li>assigns absolute mass flows on edges and nodes (<code>set_absolute_mass_flows!</code>).</li></ol></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.fill_pipes_with_initial_temperature!"><a class="docstring-binding" href="#DHNetworkSimulator.fill_pipes_with_initial_temperature!"><code>DHNetworkSimulator.fill_pipes_with_initial_temperature!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Initialize all pipe plug queues with uniform temperatures.</p><p>Fills every <code>InsulatedPipe</code> in the network with a single plug in the forward queue at <code>temperature_f</code> and a single plug in the backward queue at <code>temperature_b</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.time_step_thermal_dynamics!"><a class="docstring-binding" href="#DHNetworkSimulator.time_step_thermal_dynamics!"><code>DHNetworkSimulator.time_step_thermal_dynamics!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Advance thermal dynamics by one time step.</p><p>This is a convenience wrapper used for manual stepping outside of <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a>. It performs:</p><ol><li>forward (supply) plug advection from producer to loads,</li><li>load power consumption and cooling,</li><li>backward (return) advection back to the producer.</li></ol><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: the network (must have steady-state mass flows already computed, e.g. via <a href="#DHNetworkSimulator.steady_state_hydronynamics!"><code>steady_state_hydronynamics!</code></a>).</li><li><code>Δt::Float64</code>: time step in seconds.</li><li><code>input::ProducerOutput</code>: producer setpoints for this step.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ambient_temperature</code>: outdoor/ambient temperature in °C (or <code>nothing</code>). When <code>nothing</code>, a default of 15°C is used for load demand.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output_plugs, incoming_plug)</code> where <code>output_plugs</code> maps load labels to their inlet plug, and <code>incoming_plug</code> represents the return temperature entering the producer.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.set_load_params!"><a class="docstring-binding" href="#DHNetworkSimulator.set_load_params!"><code>DHNetworkSimulator.set_load_params!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Set load parameters for one load node.</p><p>Currently this sets only the relative mass-flow coefficient <code>m_rel</code>.</p></div></section><section><div><p>Set load parameters for multiple load nodes.</p><p><code>load_params</code> maps <code>load_label =&gt; m_rel</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.power_consumption"><a class="docstring-binding" href="#DHNetworkSimulator.power_consumption"><code>DHNetworkSimulator.power_consumption</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute load power demand as a function of outdoor temperature.</p><p>Returns power in Watts.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.consume_power!"><a class="docstring-binding" href="#DHNetworkSimulator.consume_power!"><code>DHNetworkSimulator.consume_power!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Reduce a plug temperature by consuming <code>power</code> over a time step.</p><p><code>power</code> is in Watts and <code>Δt</code> is in seconds. Updates <code>p</code> in-place.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.run_simulation"><a class="docstring-binding" href="#DHNetworkSimulator.run_simulation"><code>DHNetworkSimulator.run_simulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Run a quasi-dynamic simulation of a district heating network.</p><pre><code class="language-julia hljs">run_simulation(network, sim_time, policy; T0_f=60.0, T0_b=25.0, ambient_temperature=nothing)</code></pre><p>This is the main entry point for time stepping.</p><p>REPEAT for N time steps:</p><ol><li>computes a steady-state hydraulic solution (mass flow distribution),</li><li>advances thermal dynamics using the plug-flow method:<ul><li>forward/supply advection producer → loads,</li><li>heat consumption at loads,</li><li>backward/return advection loads → producer,</li><li>heat losses to ambient.</li></ul></li></ol><p>See <a href="../Plug_method/#Plug-method">Plug method</a> for the underlying model.</p><p><strong>Output</strong></p><ul><li><code>SimulationResults</code> struct containing time series of temperatures, flows, and powers for all nodes and edges.</li></ul><p><strong>Arguments</strong></p><ul><li><code>network::Network</code>: prepared network (producer/load nodes identified, pipes attached).</li><li><code>sim_time</code>: equally spaced time vector.<ul><li><code>Vector{Float64}</code>: time in seconds.</li><li><code>Vector{DateTime}</code>: timestamps (Δt is interpreted in seconds).</li></ul></li><li><code>policy::Function</code>: callback returning <code>ProducerOutput</code>.<ul><li>Signature: <code>policy(t, Tₐ, T_back)::ProducerOutput</code></li><li><code>Tₐ</code> is ambient temperature at time <code>t</code> or <code>nothing</code>.</li><li><code>T_back</code> is the return temperature entering the producer (in previous time step <code>k-1</code>).</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>T0_f</code>: initial temperature forward part of the network (producer → loads) (°C).</li><li><code>T0_b</code>: initial temperature in backward part of the network (loads → producer) (°C).</li><li><code>ambient_temperature</code>: optional <code>Vector{Float64}</code> of ambient (outdoor/atmospheric) temperatures (°C), length must match <code>sim_time</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SimulationResults</code>: time series of temperatures, flows, and powers.</li></ul><p><strong>Notes</strong></p><ul><li>The network structure is validated once at the start via <code>check_network!</code>.</li><li>Time steps must be equally spaced.</li></ul></div></section></details></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.plot_simulation_results"><a class="docstring-binding" href="#DHNetworkSimulator.plot_simulation_results"><code>DHNetworkSimulator.plot_simulation_results</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Plot time series from <a href="#DHNetworkSimulator.SimulationResults"><code>SimulationResults</code></a>.</p><p><code>plot_simulation_results</code> is a small helper around Plots.jl that plots one physical variable either:</p><ul><li>for selected <strong>load</strong> labels, or</li><li>for the <strong>producer</strong> (for producer-only variables).</li></ul><pre><code class="language-julia hljs">plot_simulation_results(sr::SimulationResults, physical_var::Symbol; kwargs...)
plot_simulation_results(sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)
plot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, physical_var::Symbol; kwargs...)
plot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>sr::SimulationResults</code>: simulation output from <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a>.</li><li><code>labels::Vector{String}</code>: load labels to include in plot (only used for load variables),                           if not provided, all load labels are plotted.</li><li><code>physical_var::Symbol</code>: what values to plot.   Supported options are:<ul><li>temperatures: <code>:T_load_in</code>, <code>:T_load_out</code>, <code>:T_producer_in</code>, <code>:T_producer_out</code></li><li>mass flows: <code>:mass_flow_load</code>, <code>:mass_flow_producer</code></li><li>powers: <code>:power_load</code>, <code>:power_producer</code></li></ul></li><li><code>plot::Plots.Plot{Plots.GRBackend}</code>: an existing plot to add lines to,                                      if not provided, a new plot is created.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs...</code>: forwarded to <code>Plots.plot!</code> (e.g. <code>linewidth</code>, <code>color</code>, <code>legend</code>, ...).</li></ul><p><strong>Returns</strong></p><ul><li>The <code>Plots.Plot</code> object.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>sr[:time]</code> is <code>Vector{Float64}</code>, the x-axis is converted from seconds to minutes.</li><li><code>:power_producer</code> has length <code>N-1</code> and is plotted against <code>time[1:end-1]</code>.</li><li>When plotting producer variables, the line style defaults to dashed (unless you override <code>linestyle</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sr = run_simulation(network, t, policy)

plot_simulation_results(sr, :T_load_in)
plot_simulation_results(sr, [&quot;L1&quot;, &quot;L2&quot;], :mass_flow_load)
plot_simulation_results(sr, :power_producer)</code></pre></div></section></details></article><h2 id="External-helpers"><a class="docs-heading-anchor" href="#External-helpers">External helpers</a><a id="External-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#External-helpers" title="Permalink"></a></h2><p>This package relies on MetaGraphsNext.jl internally. If you need to convert a Graphs.jl vertex index back to the stored string label, use <code>MetaGraphsNext.label_for(nw.mg, idx)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation/">« Simulation</a><a class="docs-footer-nextpage" href="../search/">Search »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 20:46">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
