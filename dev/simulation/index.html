<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation · DHNetworkSimulator</title><meta name="title" content="Simulation · DHNetworkSimulator"/><meta property="og:title" content="Simulation · DHNetworkSimulator"/><meta property="twitter:title" content="Simulation · DHNetworkSimulator"/><meta name="description" content="Documentation for DHNetworkSimulator."/><meta property="og:description" content="Documentation for DHNetworkSimulator."/><meta property="twitter:description" content="Documentation for DHNetworkSimulator."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DHNetworkSimulator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Plug_method/">Plug Method</a></li><li><span class="tocitem">Network</span><ul><li><a class="tocitem" href="../Network/">Network</a></li><li><a class="tocitem" href="../types/">Nodes and Edges</a></li></ul></li><li class="is-active"><a class="tocitem" href>Simulation</a><ul class="internal"><li><a class="tocitem" href="#Run-simulation:-run_simulation"><span>Run simulation: <code>run_simulation</code></span></a></li><li><a class="tocitem" href="#Simulation-logs:"><span>Simulation logs:</span></a></li><li><a class="tocitem" href="#Minimal-workflow-(end-to-end)"><span>Minimal workflow (end-to-end)</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h1><p>This page describes how to run simulations with DHNetworkSimulator and how to interpret the results.</p><p>The simulation follows a <strong>quasi-dynamic</strong> approach:</p><ul><li><strong>Hydraulics</strong> are treated as steady state at each time step (mass flow distribution updates “instantly”).</li><li><strong>Thermal dynamics</strong> are simulated by advecting discrete <strong>plugs</strong> of water through pipes.</li></ul><p>For details of the plug model, see <a href="../Plug_method/#Plug-method">Plug method</a>.</p><h2 id="Run-simulation:-run_simulation"><a class="docs-heading-anchor" href="#Run-simulation:-run_simulation">Run simulation: <code>run_simulation</code></a><a id="Run-simulation:-run_simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-simulation:-run_simulation" title="Permalink"></a></h2><p>The main function is <code>run_simulation(network, sim_time, policy; ...)</code>.</p><p>At a high level, for each step it:</p><ol><li>calls <code>policy(t, Tₐ, T_back)</code> to get producer setpoints (<code>ProducerOutput</code>),</li><li>computes steady-state mass flows (<code>steady_state_hydronynamics!</code>),</li><li>propagates plugs forward (supply), applies load consumption, then propagates plugs backward (return),</li><li>records temperatures / flows / powers into a <code>SimulationResults</code>.</li></ol><div class="admonition is-info" id="Network-is-validated-automatically-effb4b6b26422f0f"><header class="admonition-header">Network is validated automatically<a class="admonition-anchor" href="#Network-is-validated-automatically-effb4b6b26422f0f" title="Permalink"></a></header><div class="admonition-body"><p><code>run_simulation</code> calls <code>check_network!</code> before the first step. You do not need to call it manually as long as you constructed a valid directed tree with one producer and load leaves.</p></div></div><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.run_simulation"><a class="docstring-binding" href="#DHNetworkSimulator.run_simulation"><code>DHNetworkSimulator.run_simulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Run a quasi-dynamic simulation of a district heating network.</p><pre><code class="language-julia hljs">run_simulation(network, sim_time, policy; T0_f=60.0, T0_b=25.0, ambient_temperature=nothing)</code></pre><p>This is the main entry point for time stepping.</p><p>REPEAT for N time steps:</p><ol><li>computes a steady-state hydraulic solution (mass flow distribution),</li><li>advances thermal dynamics using the plug-flow method:<ul><li>forward/supply advection producer → loads,</li><li>heat consumption at loads,</li><li>backward/return advection loads → producer,</li><li>heat losses to ambient.</li></ul></li></ol><p>See <a href="../Plug_method/#Plug-method">Plug method</a> for the underlying model.</p><p><strong>Output</strong></p><ul><li><code>SimulationResults</code> struct containing time series of temperatures, flows, and powers for all nodes and edges.</li></ul><p><strong>Arguments</strong></p><ul><li><code>network::Network</code>: prepared network (producer/load nodes identified, pipes attached).</li><li><code>sim_time</code>: equally spaced time vector.<ul><li><code>Vector{Float64}</code>: time in seconds.</li><li><code>Vector{DateTime}</code>: timestamps (Δt is interpreted in seconds).</li></ul></li><li><code>policy::Function</code>: callback returning <code>ProducerOutput</code>.<ul><li>Signature: <code>policy(t, Tₐ, T_back)::ProducerOutput</code></li><li><code>Tₐ</code> is ambient temperature at time <code>t</code> or <code>nothing</code>.</li><li><code>T_back</code> is the return temperature entering the producer (in previous time step <code>k-1</code>).</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>T0_f</code>: initial temperature forward part of the network (producer → loads) (°C).</li><li><code>T0_b</code>: initial temperature in backward part of the network (loads → producer) (°C).</li><li><code>ambient_temperature</code>: optional <code>Vector{Float64}</code> of ambient (outdoor/atmospheric) temperatures (°C), length must match <code>sim_time</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SimulationResults</code>: time series of temperatures, flows, and powers.</li></ul><p><strong>Notes</strong></p><ul><li>The network structure is validated once at the start via <code>check_network!</code>.</li><li>Time steps must be equally spaced.</li></ul></div></section></details></article><p>Example of constant policy:</p><pre><code class="language-julia hljs">function policy(t, Tₐ, T_back)
	return ProducerOutput(mass_flow=15.0, temperature=90.0)
end</code></pre><p>Example of variable policy</p><pre><code class="language-julia hljs">function policy(t, Tₐ, T_back)
    T = 90 + 10*sin(2π*t/(24*3600)) # period of 24 hours
	return ProducerOutput(mass_flow=15.0, temperature=T)
end</code></pre><h3 id="Producer-setpoint"><a class="docs-heading-anchor" href="#Producer-setpoint">Producer setpoint</a><a id="Producer-setpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Producer-setpoint" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.ProducerOutput"><a class="docstring-binding" href="#DHNetworkSimulator.ProducerOutput"><code>DHNetworkSimulator.ProducerOutput</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Control input returned by a simulation policy.</p><p><code>ProducerOutput</code> represents the producer setpoints for one time step.</p><pre><code class="language-julia hljs">struct ProducerOutput
    mass_flow::Float64
    temperature::Float64
end</code></pre><p><strong>Fields</strong></p><ul><li><code>mass_flow</code>: total mass flow injected into the network in kg/s.</li><li><code>temperature</code>: producer outlet (supply) temperature in °C.</li></ul><p><strong>Usage</strong></p><p>The <code>policy</code> passed to <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a> must return a <code>ProducerOutput</code>:</p><pre><code class="language-julia hljs">function policy(t, Tₐ, T_back)
    return ProducerOutput(mass_flow=15.0, temperature=90.0)
end</code></pre></div></section></details></article><h2 id="Simulation-logs:"><a class="docs-heading-anchor" href="#Simulation-logs:">Simulation logs:</a><a id="Simulation-logs:-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-logs:" title="Permalink"></a></h2><p>Simulation logs data in struct <code>SimulationResults</code>.</p><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.SimulationResults"><a class="docstring-binding" href="#DHNetworkSimulator.SimulationResults"><code>DHNetworkSimulator.SimulationResults</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Results of a simulation run.</p><p><code>SimulationResults</code> stores the time series produced by <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a>.</p><pre><code class="language-julia hljs">struct SimulationResults
        time::Union{Vector{Float64}, Vector{DateTime}}
        mass_flow_load::Matrix{Float64}
        mass_flow_producer::Vector{Float64}
        T_load_in::Matrix{Float64}
        T_load_out::Matrix{Float64}
        T_producer_in::Vector{Float64}
        T_producer_out::Vector{Float64}
        power_load::Matrix{Float64}
        power_producer::Vector{Float64}
        load_labels::Dict{String, Int}
end</code></pre><p><strong>Fields</strong></p><ul><li><code>time</code>: simulation time vector.<ul><li><code>Vector{Float64}</code>: time in seconds.</li><li><code>Vector{DateTime}</code>: absolute timestamps.</li></ul></li><li><code>mass_flow_load</code>: load mass flows in kg/s. Size <code>N × nloads</code>.</li><li><code>mass_flow_producer</code>: producer mass flow in kg/s. Length <code>N</code>.</li><li><code>T_load_in</code>: temperature entering each load (supply side) in °C. Size <code>N × nloads</code>.</li><li><code>T_load_out</code>: temperature leaving each load (return side) in °C. Size <code>N × nloads</code>.</li><li><code>T_producer_in</code>: return temperature entering the producer in °C. Length <code>N</code>.</li><li><code>T_producer_out</code>: supply temperature leaving the producer in °C. Length <code>N</code>.</li><li><code>power_load</code>: load power consumption in kW. Size <code>N × nloads</code>.</li><li><code>power_producer</code>: producer power output in MW (computed from mass flow and ΔT). Length <code>N-1</code>.</li><li><code>load_labels</code>: mapping from load label to column index used in the <code>*_load</code> matrices.</li></ul><p><strong>Indexing</strong></p><p>Convenience accessors are provided:</p><ul><li><code>sr[:time]</code> returns the time vector.</li><li><code>sr[:load_labels]</code> returns the load labels.</li><li><code>sr[:load_labels_dict]</code> returns the label→column dictionary.</li><li><code>sr[&quot;L1&quot;, :T_load_in]</code> returns the time series for that load L1 (a vector).</li></ul><p><strong>Notes</strong></p><ul><li>All matrices are organized as <code>(time step, load index)</code>.</li><li><code>power_producer</code> has length <code>N-1</code> because the producer heats the water that entered in in <em>previous!</em> time step.</li></ul></div></section></details></article><h3 id="Visualization-of-SimulationResults"><a class="docs-heading-anchor" href="#Visualization-of-SimulationResults">Visualization of <code>SimulationResults</code></a><a id="Visualization-of-SimulationResults-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-SimulationResults" title="Permalink"></a></h3><p><code>SimulationResults</code> can be easily displayed using function <code>plot_simulation_results</code>.</p><article><details class="docstring" open="true"><summary id="DHNetworkSimulator.plot_simulation_results"><a class="docstring-binding" href="#DHNetworkSimulator.plot_simulation_results"><code>DHNetworkSimulator.plot_simulation_results</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Plot time series from <a href="#DHNetworkSimulator.SimulationResults"><code>SimulationResults</code></a>.</p><p><code>plot_simulation_results</code> is a small helper around Plots.jl that plots one physical variable either:</p><ul><li>for selected <strong>load</strong> labels, or</li><li>for the <strong>producer</strong> (for producer-only variables).</li></ul><pre><code class="language-julia hljs">plot_simulation_results(sr::SimulationResults, physical_var::Symbol; kwargs...)
plot_simulation_results(sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)
plot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, physical_var::Symbol; kwargs...)
plot_simulation_results(plot::Plots.Plot{Plots.GRBackend}, sr::SimulationResults, labels::Vector{String}, physical_var::Symbol; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>sr::SimulationResults</code>: simulation output from <a href="#DHNetworkSimulator.run_simulation"><code>run_simulation</code></a>.</li><li><code>labels::Vector{String}</code>: load labels to include in plot (only used for load variables),                           if not provided, all load labels are plotted.</li><li><code>physical_var::Symbol</code>: what values to plot.   Supported options are:<ul><li>temperatures: <code>:T_load_in</code>, <code>:T_load_out</code>, <code>:T_producer_in</code>, <code>:T_producer_out</code></li><li>mass flows: <code>:mass_flow_load</code>, <code>:mass_flow_producer</code></li><li>powers: <code>:power_load</code>, <code>:power_producer</code></li></ul></li><li><code>plot::Plots.Plot{Plots.GRBackend}</code>: an existing plot to add lines to,                                      if not provided, a new plot is created.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs...</code>: forwarded to <code>Plots.plot!</code> (e.g. <code>linewidth</code>, <code>color</code>, <code>legend</code>, ...).</li></ul><p><strong>Returns</strong></p><ul><li>The <code>Plots.Plot</code> object.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>sr[:time]</code> is <code>Vector{Float64}</code>, the x-axis is converted from seconds to minutes.</li><li><code>:power_producer</code> has length <code>N-1</code> and is plotted against <code>time[1:end-1]</code>.</li><li>When plotting producer variables, the line style defaults to dashed (unless you override <code>linestyle</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sr = run_simulation(network, t, policy)

plot_simulation_results(sr, :T_load_in)
plot_simulation_results(sr, [&quot;L1&quot;, &quot;L2&quot;], :mass_flow_load)
plot_simulation_results(sr, :power_producer)</code></pre></div></section></details></article><h2 id="Minimal-workflow-(end-to-end)"><a class="docs-heading-anchor" href="#Minimal-workflow-(end-to-end)">Minimal workflow (end-to-end)</a><a id="Minimal-workflow-(end-to-end)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-workflow-(end-to-end)" title="Permalink"></a></h2><p>The typical workflow is:</p><ol><li>build a <code>Network</code> (see <a href="../Network/#Network">Network</a>),</li><li>attach node/edge parameters,</li><li>define <code>sim_time</code> and <code>policy</code>, (optionally get also measurements of temperature)</li><li>call <code>run_simulation</code>,</li><li>visualize time series via <code>plot_simulation_results</code>.</li></ol><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Example-1:-sinusoidal-temperature"><a class="docs-heading-anchor" href="#Example-1:-sinusoidal-temperature">Example 1: sinusoidal temperature</a><a id="Example-1:-sinusoidal-temperature-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-sinusoidal-temperature" title="Permalink"></a></h3><pre><code class="language-julia hljs">using DHNetworkSimulator

# network = ... build/parameterize a valid Network ...

t = float.(collect(range(0, stop=3*60*60, step=60))) # simulate for three hours with 1 min time step
# sinusoidal mass flow and temperature
function policy(t, Tₐ, T_back)
    mass_flow = 15.0
    temp = 90 + 10*sin(2π*t/(100*60)) # period of 100 minutes, oscillation between 80 and 100 °C
    return ProducerOutput(mass_flow=mass_flow, temperature=temp)
end

results = run_simulation(network, t, policy; T0_f=75.0, T0_b=60.0)
plot_simulation_results(results, :T_load_in; title=&quot;Load Inlet Temperatures&quot;)</code></pre><p><img src="../figures/ex1.png" alt="example 1 result"/></p><p><em>Example 1: sinusoidal temperature on input</em></p><h3 id="Example-2:-varying-outdoor-temperature"><a class="docs-heading-anchor" href="#Example-2:-varying-outdoor-temperature">Example 2: varying outdoor temperature</a><a id="Example-2:-varying-outdoor-temperature-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-varying-outdoor-temperature" title="Permalink"></a></h3><p>In real world there is time varying outdoor temperature, which has impact on the dissipation of energy during transport (if we have good isolation, not so much). Also, consumers consume more energy, when it&#39;s cold outside.</p><p>We have a measurement of real outdoor temperature in May 2024, lets try use it!</p><p>Also, our power plans surely has some limits, let&#39;s specify the power output to be 4 MW.</p><pre><code class="language-julia hljs">time_interval = [DateTime(2024, 5, 1), DateTime(2024, 5, 21)]
Tₐ = TSFrames.subset(outdoor_temperature_ts, time_interval...) # select only relevant interval
Tₐ_vec = Tₐ[:, :T_a_avg] # convert TSFrame to vector of outdoor temperatures for each time step

t =  index(Tₐ) # get time vector in DateTime format

producer_power = 4_000_000.0 # 4 MW
c_water = 4186.0 # J/(kg*K)
function policy(t, Tₐ, T_back)
    mass_flow = 80.0 # constant mass flow of 80 kg/s
    # P = (T2-T1) * mass_flow * water_specific_heat
    temp = producer_power / (mass_flow * c_water) + T_back
    return ProducerOutput(mass_flow=mass_flow, temperature=temp)
end

results = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)
plot_simulation_results(results, :T_load_out; title=&quot;Return temperatures on load side&quot;)</code></pre><p><img src="../figures/ex2.png" alt="example 2 result"/></p><p><em>Example 2: varying outdoor temperature</em></p><h3 id="Example-3:-control-the-output-temperature-with-constrained-power"><a class="docs-heading-anchor" href="#Example-3:-control-the-output-temperature-with-constrained-power">Example 3: control the output temperature with constrained power</a><a id="Example-3:-control-the-output-temperature-with-constrained-power-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-control-the-output-temperature-with-constrained-power" title="Permalink"></a></h3><p>It&#39;s easy to say &quot;let&#39;s just produce water of 90°C&quot;. To do that, we have to heat up the water and for that to happen, we must give the water considerable amount of energy. In real world, producers have some upper limits of energy they can deliver per second.</p><p>Let&#39;s model that!</p><pre><code class="language-julia hljs"># ... t, Tₐ_vec same as in previous example... #

T_target = 90               # our target temperature
Pwr_max =  5_000_000.0      # maximal power output 5 MW
function policy(t, Tₐ, T_back)
    mass_flow = 80.0
    P_target = (T_target - T_back) * mass_flow * c_water # power needed to reach T_target
    P = min(P_target, Pwr_max)
    temp = P / (mass_flow * c_water) + T_back
    return ProducerOutput(mass_flow=mass_flow, temperature=temp)
end

results = run_simulation(network, t, policy; T0_f=75.0, T0_b=70.0, ambient_temperature=Tₐ_vec)
plot_simulation_results(results, :T_producer_out; title=&quot;Producer output temperature&quot;, linestyle=:solid)
plot_simulation_results(results, :power_load)</code></pre><p><img src="../figures/ex31.png" alt="example 3 producer output"/></p><p><em>Example 3: Producer is able to control temperature to 90°C most of the time.</em></p><p><img src="../figures/ex32.png" alt="example 3 producer output"/></p><p><em>Example 3: Power consumption of loads depend on temperature, we see, that in some intervals, it sums up so much, that the total power consumption is higher that power production and water gets colder.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Nodes and Edges</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 06:51">Friday 13 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
